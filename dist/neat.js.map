{"version":3,"sources":["connection_gene.js","helpers.js","node_gene.js","parameters.js","feed_forward_network.js","genome.js","innovation_generator.js","species.js","evaluator.js","neat.js"],"names":["ConnectionGene","inNode","outNode","weight","enabled","innovation","randInt","l","r","Math","floor","random","rand","randGaussian","u","v","sqrt","log","cos","PI","TYPE","INPUT","HIDDEN","OUTPUT","NodeGene","type","id","Object","defineProperty","value","writable","PARAMETERS","RandomWeightRange","probGenomeMutateConnectionWeights","probEachWeightUniformPerturb","c1","c2","c3","compatibilityThreshold","addConnectionRate","addNodeRate","cullRate","asexualReproductionRate","elitismRate","mutateToggleEnable","disableGeneInheritingChance","minSpeciesSize","PopulationSize","FeedForwardNetwork","genome","network","i","nodes","length","push","neuron","Neuron","incoming","weights","sort","n1","n2","connections","inId","outId","getNeuronIndex","m","idx","activated","calculateNeuronOutput","inNeuron","activateSigmoid","inputs","j","outputs","resetValues","visited","inStack","dfs","Array","fill","exp","max","Genome","fitness","connectionCounter","node1","node2","reversed","connectionImpossible","connectionExists","newConnection","getInnovation","addConnection","nodeCounter","connection","getNodeById","newNode","inToNew","newToOut","addNode","node","find","undefined","newConnections","newNodes","copy","newGenome","checkCycles","pop","crossover","parent1","parent2","child","matchingNode","childNodeGene","matchingConnection","getConnection","childConnectionGene","compatibilityDistance","genome1","genome2","N","compatibilities","getGenesCompatibility","excess","disjoint","avgWeightDiff","nodesMatching","connectionMatching","nodegenes1","map","id1","id2","nodegenes2","weightDiff","connectiongenes1","conn1","conn2","connectiongenes2","abs","matching","InnovationGenerator","currentInnovation","Species","representative","members","totalAdjustedFitness","adjustedFitness","splice","g1","g2","killTill","ceil","reproduce","species","nodeInnovation","connectionInnovation","speciesRemaining","previousSize","s","p","spawnAmounts","computeSpawnAmounts","newPopulation","spawn","Error","oldMembers","g","mutateConnectionWeights","addConnectionMutation","addNodeMutation","afSum","reduce","a","b","d","c","round","totalSpawn","norm","Evaluator","startingGenome","constructor","populationSize","genomes","initialGenome","randomizeAllWeights","nextGenGenomes","highestScore","fittestGenome","generation","reset","speciesFound","newSpecies","score","evaluateGenome","adjustedScore","addAdjustedFitness","cull","window"],"mappings":"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","file":"neat.js","sourceRoot":"../src","sourcesContent":["export default class ConnectionGene {\n    constructor(inNode, outNode, weight, enabled, innovation) {\n        this.inNode = inNode;\n        this.outNode = outNode;\n        this.weight = weight;\n        this.enabled = enabled;\n        this.innovation = innovation;\n    }\n\n    copy() {\n        return new ConnectionGene(this.inNode, this.outNode, this.weight, this.enabled, this.innovation);\n    }\n};\n","export function randInt(l, r) {\n    return Math.floor(Math.random() * (r - l + 1)) + l;\n}\n\nexport function rand(l, r) {\n    return Math.random() * (r - l) + l;\n}\n\nexport function randGaussian() {\n    var u = 0, v = 0;\n    while(u === 0) u = Math.random(); //Converting [0,1) to (0,1)\n    while(v === 0) v = Math.random();\n    return Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );\n}","const TYPE = {\n    INPUT: 0,\n    HIDDEN: 1,\n    OUTPUT: 2\n};\n\nexport default class NodeGene {\n    constructor(type, id) {\n        this.type = type;\n        this.id = id;\n    }\n\n    copy() {\n        return new NodeGene(this.type, this.id);\n    }\n};\n\nObject.defineProperty(NodeGene, 'TYPE', {\n    value: TYPE,\n    writable: false\n});\n","const PARAMETERS = {\n    RandomWeightRange: 4,\n    probGenomeMutateConnectionWeights: 0.8,\n    probEachWeightUniformPerturb: 0.9,\n    c1: 2,\n    c2: 2,\n    c3: 0.4,\n    compatibilityThreshold: 3,\n    addConnectionRate: 0.4,\n    addNodeRate: 0.25,\n    cullRate: 0.8,\n    asexualReproductionRate: 0.25,\n    elitismRate: 0.1,\n    // TODO: implement mutateToggleEnable\n    mutateToggleEnable: 0.3,\n    disableGeneInheritingChance: 0.3,\n    minSpeciesSize: 1,\n    PopulationSize: 100\n};\n\nexport default PARAMETERS;\n","import NodeGene from \"./node_gene\";\n\n// TODO: implement RNN too!\nexport default class FeedForwardNetwork {\n    constructor(genome) {\n        this.network = [];\n        for(let i=0; i<genome.nodes.length; ++i) {\n            this.network.push({\n                neuron: new Neuron(genome.nodes[i].id, genome.nodes[i].type),\n                incoming: [],\n                weights: []\n            });\n        }\n        this.network.sort((n1, n2) => n1.neuron.id < n2.neuron.id ? -1 : 1);\n        for(let i=0; i < genome.connections.length; ++i) {\n            if(genome.connections[i].enabled) {\n                let inId = genome.connections[i].inNode;\n                let outId = genome.connections[i].outNode;\n                this.network[this.getNeuronIndex(outId)].incoming.push(inId);\n                this.network[this.getNeuronIndex(outId)].weights.push(genome.connections[i].weight);\n            }\n        }\n    }\n\n    // search neuron index in network using binary search\n    getNeuronIndex(id) {\n        let l = 0, r = this.network.length - 1;\n        while(l <= r) {\n            let m = Math.floor((l + r) / 2);\n            if(this.network[m].neuron.id === id) {\n                return m;\n            }\n            else if(this.network[m].neuron.id < id) {\n                l = m + 1;\n            }\n            else {\n                r = m - 1;\n            }\n        }\n    }\n\n    calculateNeuronOutput(id) {\n        let idx = this.getNeuronIndex(id);\n        if(this.network[idx].neuron.activated) {\n            return;\n        }\n\n        for(let i=0; i<this.network[idx].incoming.length; ++i) {\n            this.calculateNeuronOutput(this.network[idx].incoming[i]);\n            let inNeuron = this.network[this.getNeuronIndex(this.network[idx].incoming[i])].neuron;\n            this.network[idx].neuron.value += inNeuron.value * this.network[idx].weights[i];\n        }\n\n        this.network[idx].neuron.activateSigmoid();\n    }\n\n    feed(inputs) {\n        let j = 0;\n        for(let i=0; i<this.network.length; ++i) {\n            if(this.network[i].neuron.type === NodeGene.TYPE.INPUT) {\n                this.network[i].neuron.value = inputs[j];\n                this.network[i].neuron.activated = true;\n                ++j;\n            }\n            if(j === inputs.length)\n                break;\n        }\n\n        let outputs = [];\n        for(let i=0; i<this.network.length; ++i) {\n            if(this.network[i].neuron.type === NodeGene.TYPE.OUTPUT) {\n                this.calculateNeuronOutput(this.network[i].neuron.id);\n                outputs.push(this.network[i].neuron.value);\n            }\n        }\n\n        this.resetValues();\n        return outputs;\n    }\n\n    dfs(u) {\n        let idx = this.getNeuronIndex(u);\n        if(!this.visited[idx]) {\n            this.visited[idx] = true;\n            this.inStack[idx] = true;\n\n            for(let i=0; i<this.network[idx].incoming.length; ++i) {\n                let v = this.network[idx].incoming[i];\n                if(!this.visited[this.getNeuronIndex(v)] && this.dfs(v))\n                    return true;\n                else if(this.inStack[this.getNeuronIndex(v)])\n                    return true;\n            }\n        }\n\n        this.inStack[idx] = false;\n        return false;\n    }\n\n    checkCycles() {\n        this.visited = new Array(this.network.length);\n        this.visited.fill(false);\n        this.inStack = new Array(this.network.length);\n        this.inStack.fill(false);\n        for(let i=0; i<this.network.length; ++i) {\n            if(this.dfs(this.network[i].neuron.id))\n                return true;\n        }\n        \n        return false;\n    }\n\n    resetValues() {\n        for(let i=0; i<this.network.length; ++i) {\n            this.network[i].neuron.value = 0;\n            this.network[i].neuron.activated = false;\n        }\n    }\n};\n\nclass Neuron {\n    constructor(id, type) {\n        this.id = id;\n        this.type = type;\n        this.activated = false;\n        this.value = 0;\n    }\n\n    activateSigmoid() {\n        this.value = 1 / (1 + Math.exp(-this.value));\n        this.activated = true;\n    }\n\n    activateRelu() {\n        this.value = Math.max(this.value, 0);\n        this.activated = true;\n    }\n};\n","import ConnectionGene from './connection_gene';\nimport { randInt, rand, randGaussian } from './helpers';\nimport NodeGene from './node_gene';\nimport PARAMETERS from './parameters';\nimport FeedForwardNetwork from './feed_forward_network';\n\nexport default class Genome {\n    constructor() {\n        this.connections = [];\n        this.nodes = [];\n        this.fitness = 0;\n    }\n\n    // TODO: add tries\n    addConnectionMutation(connectionCounter) {\n        let node1 = this.nodes[randInt(0, this.nodes.length - 1)];\n        let node2 = this.nodes[randInt(0, this.nodes.length - 1)];\n        let weight = rand(-PARAMETERS.RandomWeightRange / 2, PARAMETERS.RandomWeightRange / 2);\n\n        let reversed = false;\n        if(node1.type === NodeGene.TYPE.HIDDEN && node2.type === NodeGene.TYPE.INPUT)\n            reversed = true;\n        else if(node1.type === NodeGene.TYPE.OUTPUT && node2.type === NodeGene.TYPE.HIDDEN)\n            reversed = true;\n        else if(node1.type === NodeGene.TYPE.OUTPUT && node2.type === NodeGene.TYPE.INPUT)\n            reversed = true;\n\n        let connectionImpossible = false;\n        if(node1.type === NodeGene.TYPE.INPUT && node2.type === NodeGene.TYPE.INPUT)\n            connectionImpossible = true;\n        else if(node1.type === NodeGene.TYPE.OUTPUT && node2.type === NodeGene.TYPE.OUTPUT)\n            connectionImpossible = true;\n        else if(node1.id === node2.id)\n            connectionImpossible = true;\n        \n        let connectionExists = false;\n        for(let i=0; i<this.connections.length; ++i) {\n            if(this.connections[i].inNode === node1.id && this.connections[i].outNode === node2.id) {\n                connectionExists = true;\n                break;\n            }\n            if(this.connections[i].inNode === node2.id && this.connections[i].outNode === node1.id) {\n                connectionExists = true;\n                break;\n            }\n        }\n\n        if(connectionExists || connectionImpossible)\n        return;\n        \n        let newConnection = new ConnectionGene(reversed ? node2.id : node1.id, reversed ? node1.id : node2.id, weight, true, connectionCounter.getInnovation());\n        this.addConnection(newConnection);\n    }\n\n    addNodeMutation(nodeCounter, connectionCounter) {\n        let connection = this.connections[randInt(0, this.connections.length - 1)];\n        let inNode = this.getNodeById(connection.inNode);\n        let outNode = this.getNodeById(connection.outNode);\n\n        connection.enabled = false;\n\n        let newNode = new NodeGene(NodeGene.TYPE.HIDDEN, nodeCounter.getInnovation());\n        let inToNew = new ConnectionGene(inNode.id, newNode.id, 1, true, connectionCounter.getInnovation());\n        let newToOut = new ConnectionGene(newNode.id, outNode.id, connection.weight, true, connectionCounter.getInnovation());\n        \n        this.addNode(newNode);\n        this.addConnection(inToNew);\n        this.addConnection(newToOut);\n    }\n\n    mutateConnectionWeights() {\n        for(let i=0; i<this.connections.length; ++i) {\n            if(rand(0, 1) < PARAMETERS.probEachWeightUniformPerturb) {\n                this.connections[i].weight += randGaussian();\n            }\n            else {\n                this.connections[i].weight = rand(-PARAMETERS.RandomWeightRange / 2, PARAMETERS.RandomWeightRange / 2);\n            }\n        }\n    }\n\n    getNodeById(id) {\n        let node =  this.nodes.find(node => node.id === id);\n        if(node === undefined)\n            return null;\n        return node;\n    }\n\n    getConnection(innovation) {\n        let connection = this.connections.find(connection => connection.innovation === innovation);\n        if(connection === undefined)\n            return null;\n        return connection;\n    }\n\n    // TODO: use GenesisGenome\n    randomizeAllWeights() {\n        for(let i=0; i<this.connections.length; ++i) {\n            this.connections[i].weight = rand(-PARAMETERS.RandomWeightRange / 2, PARAMETERS.RandomWeightRange / 2);\n        }\n    }\n\n    copy() {\n        let newConnections = [];\n        let newNodes = [];\n        for(let i=0; i<this.connections.length; ++i)\n            newConnections.push(this.connections[i].copy());\n        for(let i=0; i<this.nodes.length; ++i)\n            newNodes.push(this.nodes[i].copy());\n        \n        let newGenome = new Genome();\n        newGenome.connections = newConnections;\n        newGenome.nodes = newNodes;\n        newGenome.fitness = this.fitness;\n        return newGenome;\n    }\n\n    addNode(node) {\n        this.nodes.push(node);\n    }\n\n    addConnection(connection) {\n        this.connections.push(connection);\n        let net = new FeedForwardNetwork(this);\n        if(!net.checkCycles()) {\n            return true;\n        }\n        else {\n            this.connections.pop();\n            return false;\n        } \n    }\n};\n\n// parent1 should be fitter than parent2\nGenome.crossover = function(parent1, parent2) {\n    let child = new Genome();\n\n    for(let i=0; i<parent1.nodes.length; ++i) {\n        let matchingNode = parent2.getNodeById(parent1.nodes[i].id);\n        if(matchingNode !== null) {\n            let childNodeGene = Math.random() >= 0.5 ? parent1.nodes[i].copy() : matchingNode.copy();\n            child.addNode(childNodeGene);\n        }\n        else {\n            let childNodeGene = parent1.nodes[i].copy();\n            child.addNode(childNodeGene);\n        }\n    }\n    for(let i=0; i<parent1.connections.length; ++i) {\n        let matchingConnection = parent2.getConnection(parent1.connections[i].innovation);\n        let childConnectionGene;\n        if(matchingConnection !== null) {\n            childConnectionGene = Math.random() >= 0.5 ? parent1.connections[i].copy() : matchingConnection.copy();\n            let disabled = !parent1.connections[i].enabled || !matchingConnection.enabled;\n            if(disabled && Math.random() < PARAMETERS.disableGeneInheritingChance)\n                childConnectionGene.enabled = false;\n            child.addConnection(childConnectionGene);\n        }\n        else {\n            childConnectionGene = parent1.connections[i].copy();\n            child.addConnection(childConnectionGene);\n        }\n    }\n    return child;\n}\n\nGenome.compatibilityDistance = function(genome1, genome2) {\n    let N = Math.max(genome1.nodes.length + genome1.connections.length, genome2.nodes.length + genome2.connections.length);\n    let compatibilities = Genome.getGenesCompatibility(genome1, genome2);\n    // TODO: check value of N\n    // N = 1;\n    return (PARAMETERS.c1 * compatibilities.excess / N) + (PARAMETERS.c2 * compatibilities.disjoint / N) + (PARAMETERS.c3 * compatibilities.avgWeightDiff);\n};\n\nGenome.getGenesCompatibility = function(genome1, genome2) {\n    let nodesMatching = 0, connectionMatching = 0, disjoint = 0, excess = 0;\n    // count matching node genes\n    let nodegenes1 = genome1.nodes.map(node => node.id).sort((id1, id2) => id1 < id2 ? -1: 1);\n    let nodegenes2 = genome2.nodes.map(node => node.id).sort((id1, id2) => id1 < id2 ? -1: 1);\n\n    let i = nodegenes1.length - 1;\n    let j = nodegenes2.length - 1;\n    while(i >= 0 && j >= 0) {\n        if(nodegenes1[i] === nodegenes2[j]) {\n            ++nodesMatching;\n            --i;\n            --j;\n        }\n        else {\n            if(nodegenes1[i] < nodegenes2[j]) {\n                if(nodegenes2[j] > nodegenes1[nodegenes1.length - 1])\n                    ++excess;\n                else\n                    ++disjoint;\n                --j;\n            }\n            else {\n                if(nodegenes1[i] > nodegenes2[nodegenes2.length - 1])\n                    ++excess;\n                else\n                    ++disjoint;\n                --i;\n            }\n        }\n    }\n\n    // count matching connection genes\n    let weightDiff = 0;\n    let connectiongenes1 = genome1.connections.map(connection => { return { innovation : connection.innovation, weight: connection.weight } })\n                                              .sort((conn1, conn2) => conn1.innovation < conn2.innovation ? -1: 1);\n    let connectiongenes2 = genome2.connections.map(connection => { return { innovation : connection.innovation, weight: connection.weight } })\n                                              .sort((conn1, conn2) => conn1.innovation < conn2.innovation ? -1: 1);\n\n    i = connectiongenes1.length - 1;\n    j = connectiongenes2.length - 1;\n    while(i >= 0 && j >= 0) {\n        if(connectiongenes1[i].innovation === connectiongenes2[j].innovation) {\n            ++connectionMatching;\n            weightDiff += Math.abs(connectiongenes1[i].weight - connectiongenes2[j].weight);\n            --i;\n            --j;\n        }\n        else {\n            if(connectiongenes1[i].innovation < connectiongenes2[j].innovation) {\n                if(connectiongenes2[j].innovation > connectiongenes1[connectiongenes1.length - 1].innovation)\n                    ++excess;\n                else\n                    ++disjoint;\n                --j;\n            }\n            else {\n                if(connectiongenes1[i].innovation > connectiongenes2[connectiongenes2.length - 1].innovation)\n                    ++excess;\n                else\n                    ++disjoint;\n                --i;\n            }\n        }\n    }\n    let avgWeightDiff = connectionMatching > 0 ? weightDiff / connectionMatching : 0;\n    return {\n        matching: nodesMatching + connectionMatching,\n        disjoint: disjoint,\n        excess: excess,\n        avgWeightDiff: avgWeightDiff\n    };\n}\n","export default class InnovationGenerator {\n    constructor() {\n        let currentInnovation = -1;\n\n        this.getInnovation = function() {\n            ++ currentInnovation;\n            return currentInnovation;\n        };  \n    }\n}","import { randInt } from \"./helpers\";\nimport PARAMETERS from \"./parameters\";\nimport Genome from \"./genome\";\n\n// TODO: set compatibility threshold dynamically to make no of species remain constant\nexport default class Species {\n    constructor(representative) {\n        this.representative = representative;\n        this.members = [representative];\n        this.totalAdjustedFitness = 0;\n    }\n\n    addAdjustedFitness(adjustedFitness) {\n        this.totalAdjustedFitness += adjustedFitness;\n    }\n\n    reset() {\n        this.representative = this.members[randInt(0, this.members.length - 1)];\n        this.members.splice(0, this.members.length);\n        this.totalAdjustedFitness = 0;\n    }\n\n    cull() {\n        this.members.sort((g1, g2) => g1.fitness > g2.fitness ? -1: 1);\n        let killTill = Math.ceil(this.members.length * (1 - PARAMETERS.cullRate));\n        for(let i = this.members.length; i >= killTill; --i) {\n            this.members.splice(i, 1);\n        }\n    }\n\n};\n\n\nSpecies.reproduce = function(species, nodeInnovation, connectionInnovation) {\n    // TODO: implement stagnation\n    let speciesRemaining = [...species];\n    let previousSize = speciesRemaining.map(s => s.members.length);\n    let minSpeciesSize = previousSize.map(p => Math.max(PARAMETERS.elitismRate * p, PARAMETERS.minSpeciesSize));\n    let adjustedFitness = speciesRemaining.map(s => s.totalAdjustedFitness);\n\n    let spawnAmounts = Species.computeSpawnAmounts(previousSize, minSpeciesSize, adjustedFitness);\n\n    let newPopulation = [];\n    // console.log(previousSize, minSpeciesSize, adjustedFitness, spawnAmounts);\n    \n    for(let i=0; i<speciesRemaining.length; ++i) {\n        let s = speciesRemaining[i];\n        let spawn = Math.max(previousSize[i] * PARAMETERS.elitismRate, spawnAmounts[i]);\n        if(spawn < 0)\n            throw new Error(\"Spawning should be positive\");\n        \n        let oldMembers = s.members.map(g => g.copy());\n\n        oldMembers.sort((g1, g2) => g1.fitness > g2.fitness ? -1: 1);\n        for(let j=0; j<Math.floor(s.members.length * PARAMETERS.elitismRate); ++j) {\n            newPopulation.push(s.members[j]);\n            --spawn;\n        }\n\n        if(spawn <= 0)\n            continue;\n\n        // TODO: implement survival threshold\n        while(spawn > 0) {\n            spawn -= 1;\n\n            let id1 = randInt(0, oldMembers.length - 1);\n            let id2 = randInt(0, oldMembers.length - 1);\n            let parent1 = oldMembers[id1];\n            let parent2 = oldMembers[id2];\n            let child;\n            \n            if(Math.random() > PARAMETERS.asexualReproductionRate && id1 !== id2) {\n                if(parent1.fitness > parent2.fitness) {\n                    child = Genome.crossover(parent1, parent2);\n                }\n                else {\n                    child = Genome.crossover(parent2, parent1);\n                }\n                if(Math.random() < PARAMETERS.probGenomeMutateConnectionWeights)\n                    child.mutateConnectionWeights();\n                if(Math.random() < PARAMETERS.addConnectionRate)\n                    child.addConnectionMutation(connectionInnovation);\n                if(Math.random() < PARAMETERS.addNodeRate)\n                    child.addNodeMutation(nodeInnovation, connectionInnovation);\n            }\n            else {\n                child = parent1.copy();\n                if(Math.random() < PARAMETERS.probGenomeMutateConnectionWeights)\n                    child.mutateConnectionWeights();\n            }\n\n            newPopulation.push(child);\n        }\n    }\n    return newPopulation;\n};\n\nSpecies.computeSpawnAmounts = function(previousSize, minSpeciesSize, adjustedFitness) {\n    let afSum = adjustedFitness.reduce((a, b) => a + b, 0);\n    let spawnAmounts = [];\n\n    for(let i=0; i<adjustedFitness.length; ++i) {\n        let s = Math.max(minSpeciesSize[i], (adjustedFitness[i] / afSum) * PARAMETERS.PopulationSize);\n        // TODO: check why / 2\n        let d = (s - previousSize[i]) / 2;\n        let c = Math.round(d);\n        \n        let spawn = previousSize[i];\n        if(Math.abs(c) > 0)\n            spawn += c;\n        else if(d > 0)\n            spawn += 1;\n        else\n            spawn -= 1;\n\n        spawnAmounts.push(spawn);\n    }\n    let totalSpawn = spawnAmounts.reduce((a, b) => a + b, 0);\n    let norm = PARAMETERS.PopulationSize / totalSpawn;\n    spawnAmounts = spawnAmounts.map((s, i) => Math.max(minSpeciesSize[i], Math.round(norm * s)));\n    // spawnAmounts = spawnAmounts.map((s, i) => Math.round(norm * s));\n\n    return spawnAmounts;\n}","import Species from './species';\nimport Genome from './genome';\nimport PARAMETERS from './parameters';\n\nexport default class Evaluator {\n    constructor(startingGenome, connectionInnovation, nodeInnovation) {\n        if(this.constructor === Evaluator) {\n            throw new Error(\"Evaluator cannot be instantiated\");\n        }\n\n        this.populationSize = PARAMETERS.PopulationSize;\n        this.genomes = [];\n        for(let i=0; i<this.populationSize; ++i) {\n            let initialGenome = startingGenome.copy();\n            initialGenome.randomizeAllWeights();\n            this.genomes.push(initialGenome);\n        }\n        this.nextGenGenomes = [];\n        this.species = [];\n\n        this.connectionInnovation = connectionInnovation;\n        this.nodeInnovation = nodeInnovation;\n\n        this.highestScore = 0;\n        this.fittestGenome;\n\n        this.generation = 0;\n    }\n\n    evaluate() {\n        // reset everything for next generation\n        for(let i=0; i<this.species.length; ++i)\n            this.species[i].reset();\n        this.nextGenGenomes = [];\n        this.fittestGenome = null;\n        this.highestScore = 0;\n\n        // Place genomes into species\n        for(let i=0; i<this.genomes.length; ++i) {\n            let speciesFound = false;\n            for(let j=0; j<this.species.length; ++j) {\n                if(Genome.compatibilityDistance(this.genomes[i], this.species[j].representative) < PARAMETERS.compatibilityThreshold) {\n                    this.species[j].members.push(this.genomes[i]);\n                    speciesFound = true;\n                    break;\n                }\n            }\n            if(!speciesFound) {\n                let newSpecies = new Species(this.genomes[i]);\n                this.species.push(newSpecies);\n            }\n        }\n\n        // Evaluate genomes and assign fitness\n        for(let i=0; i<this.species.length; ++i) {\n            for(let j=0; j<this.species[i].members.length; ++j) {\n                let s = this.species[i];\n                let g = this.species[i].members[j];\n\n                let score = this.evaluateGenome(g);\n                let adjustedScore = score / s.members.length;\n                s.addAdjustedFitness(adjustedScore);\n                g.fitness = adjustedScore;\n                if(score > this.highestScore) {\n                    this.highestScore = score;\n                    this.fittestGenome = g;\n                }\n            }\n        }\n\n\n        // Cull genome in each Species\n        for(let i=0; i<this.species.length; ++i) {\n            this.species[i].cull();\n        }\n\n        // remove empty species\n        for(let i=this.species.length - 1; i >= 0; --i) {\n            if(this.species[i].members.length === 0) {\n                this.species.splice(i, 1);\n            }\n        }\n\n        // breed rest of the genomes\n        this.nextGenGenomes = Species.reproduce(this.species, this.nodeInnovation, this.connectionInnovation);\n\n        this.genomes = [...this.nextGenGenomes];\n        this.populationSize = this.genomes.length;\n\n        ++this.generation;\n    }\n\n    evaluateGenome(genome) {\n        throw new Error(\"Method evaluateGenome() must be implemented\");\n    }\n    \n};\n","import Genome from './genome';\nimport InnovationGenerator from './innovation_generator';\nimport NodeGene from './node_gene';\nimport ConnectionGene from './connection_gene';\nimport Evaluator from './evaluator';\nimport FeedForwardNetwork from './feed_forward_network';\n\nwindow.Genome = Genome;\nwindow.NodeGene = NodeGene;\nwindow.ConnectionGene = ConnectionGene;\nwindow.InnovationGenerator = InnovationGenerator;\nwindow.Evaluator = Evaluator;\nwindow.FeedForwardNetwork = FeedForwardNetwork;"]}