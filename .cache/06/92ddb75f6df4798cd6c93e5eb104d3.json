{"id":"species.js","dependencies":[{"name":"/home/vedhant/ml/neat/package.json","includedInParent":true,"mtime":1571574106382},{"name":"./helpers","loc":{"line":1,"column":24},"parent":"/home/vedhant/ml/neat/src/species.js","resolved":"/home/vedhant/ml/neat/src/helpers.js"},{"name":"./parameters","loc":{"line":2,"column":23},"parent":"/home/vedhant/ml/neat/src/species.js","resolved":"/home/vedhant/ml/neat/src/parameters.js"},{"name":"./genome","loc":{"line":3,"column":19},"parent":"/home/vedhant/ml/neat/src/species.js","resolved":"/home/vedhant/ml/neat/src/genome.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helpers = require(\"./helpers\");\n\nvar _parameters = _interopRequireDefault(require(\"./parameters\"));\n\nvar _genome = _interopRequireDefault(require(\"./genome\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// TODO: set compatibility threshold dynamically to make no of species remain constant\nvar Species =\n/*#__PURE__*/\nfunction () {\n  function Species(representative) {\n    _classCallCheck(this, Species);\n\n    this.representative = representative;\n    this.members = [representative];\n    this.totalAdjustedFitness = 0;\n  }\n\n  _createClass(Species, [{\n    key: \"addAdjustedFitness\",\n    value: function addAdjustedFitness(adjustedFitness) {\n      this.totalAdjustedFitness += adjustedFitness;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.members.sort(function (g1, g2) {\n        return g1.fitness > g2.fitness ? -1 : 1;\n      });\n      this.representative = this.members[0];\n      this.members.splice(0, this.members.length);\n      this.totalAdjustedFitness = 0;\n    }\n  }, {\n    key: \"cull\",\n    value: function cull() {\n      this.members.sort(function (g1, g2) {\n        return g1.fitness > g2.fitness ? -1 : 1;\n      });\n      var killTill = Math.ceil(this.members.length * (1 - _parameters.default.cullRate));\n\n      for (var i = this.members.length; i >= killTill; --i) {\n        this.members.splice(i, 1);\n      }\n    }\n  }]);\n\n  return Species;\n}();\n\nexports.default = Species;\n;\n\nSpecies.reproduce = function (species, nodeInnovation, connectionInnovation) {\n  // TODO: implement stagnation\n  var speciesRemaining = _toConsumableArray(species);\n\n  var previousSize = speciesRemaining.map(function (s) {\n    return s.members.length;\n  });\n  var minSpeciesSize = previousSize.map(function (p) {\n    return Math.max(_parameters.default.elitismRate * p, _parameters.default.minSpeciesSize);\n  });\n  var adjustedFitness = speciesRemaining.map(function (s) {\n    return s.totalAdjustedFitness;\n  });\n  var spawnAmounts = Species.computeSpawnAmounts(previousSize, minSpeciesSize, adjustedFitness);\n  var newPopulation = []; // console.log(previousSize, minSpeciesSize, adjustedFitness, spawnAmounts);\n\n  for (var i = 0; i < speciesRemaining.length; ++i) {\n    var s = speciesRemaining[i];\n    var spawn = Math.max(previousSize[i] * _parameters.default.elitismRate, spawnAmounts[i]);\n    if (spawn < 0) throw new Error(\"Spawning should be positive\");\n    var oldMembers = s.members.map(function (g) {\n      return g.copy();\n    });\n    oldMembers.sort(function (g1, g2) {\n      return g1.fitness > g2.fitness ? -1 : 1;\n    });\n\n    for (var j = 0; j < Math.ceil(s.members.length * _parameters.default.elitismRate); ++j) {\n      newPopulation.push(s.members[j]);\n      --spawn;\n    }\n\n    if (spawn <= 0) continue;\n    var cutOff = Math.ceil(_parameters.default.survivalThreshold * oldMembers.length);\n    if (oldMembers.length > 1) cutOff = Math.max(2, cutOff);\n\n    while (cutOff < oldMembers.length) {\n      oldMembers.pop();\n    }\n\n    while (spawn > 0) {\n      spawn -= 1;\n      var id1 = (0, _helpers.randInt)(0, oldMembers.length - 1);\n      var id2 = (0, _helpers.randInt)(0, oldMembers.length - 1);\n      var parent1 = oldMembers[id1];\n      var parent2 = oldMembers[id2];\n      var child = void 0;\n\n      if (Math.random() > _parameters.default.asexualReproductionRate && id1 !== id2) {\n        if (parent1.fitness > parent2.fitness) {\n          child = _genome.default.crossover(parent1, parent2);\n        } else {\n          child = _genome.default.crossover(parent2, parent1);\n        }\n\n        if (Math.random() < _parameters.default.probGenomeMutateConnectionWeights) child.mutateConnectionWeights();\n        if (Math.random() < _parameters.default.addConnectionRate) child.addConnectionMutation(connectionInnovation);\n        if (Math.random() < _parameters.default.addNodeRate) child.addNodeMutation(nodeInnovation, connectionInnovation);\n      } else {\n        child = parent1.copy();\n        if (Math.random() < _parameters.default.probGenomeMutateConnectionWeights) child.mutateConnectionWeights();\n      }\n\n      newPopulation.push(child);\n    }\n  }\n\n  return newPopulation;\n};\n\nSpecies.computeSpawnAmounts = function (previousSize, minSpeciesSize, adjustedFitness) {\n  var afSum = adjustedFitness.reduce(function (a, b) {\n    return a + b;\n  }, 0);\n  var spawnAmounts = [];\n\n  for (var i = 0; i < adjustedFitness.length; ++i) {\n    var s = Math.max(minSpeciesSize[i], adjustedFitness[i] / afSum * _parameters.default.PopulationSize); // TODO: check why / 2\n\n    var d = (s - previousSize[i]) / 2;\n    var c = Math.round(d);\n    var spawn = previousSize[i];\n    if (Math.abs(c) > 0) spawn += c;else if (d > 0) spawn += 1;else spawn -= 1;\n    spawnAmounts.push(spawn);\n  }\n\n  var totalSpawn = spawnAmounts.reduce(function (a, b) {\n    return a + b;\n  }, 0);\n  var norm = _parameters.default.PopulationSize / totalSpawn;\n  spawnAmounts = spawnAmounts.map(function (s, i) {\n    return Math.max(minSpeciesSize[i], Math.round(norm * s));\n  }); // spawnAmounts = spawnAmounts.map((s, i) => Math.round(norm * s));\n\n  return spawnAmounts;\n};\n\nSpecies.speciate = function (species, genomes) {\n  // Place genomes into species\n  for (var i = 0; i < species.length; ++i) {\n    species[i].reset();\n  }\n\n  for (var _i = 0; _i < genomes.length; ++_i) {\n    var speciesFound = false;\n\n    for (var j = 0; j < species.length; ++j) {\n      if (_genome.default.compatibilityDistance(genomes[_i], species[j].representative) < _parameters.default.compatibilityThreshold) {\n        species[j].members.push(genomes[_i]);\n        speciesFound = true;\n        genomes[_i].species = j;\n        break;\n      }\n    }\n\n    if (!speciesFound) {\n      var newSpecies = new Species(genomes[_i]);\n      species.push(newSpecies);\n      genomes[_i].species = species.length - 1;\n    }\n  }\n\n  return species;\n};"},"sourceMaps":null,"error":null,"hash":"530cc2c515cb77f790591f74fe3351c6","cacheData":{"env":{}}}