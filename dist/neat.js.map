{"version":3,"sources":["connection_gene.js","helpers.js","node_gene.js","parameters.js","feed_forward_network.js","genome.js","innovation_generator.js","species.js","evaluator.js","neat.js"],"names":["ConnectionGene","inNode","outNode","weight","enabled","innovation","randInt","l","r","Math","floor","random","rand","randGaussian","u","v","sqrt","log","cos","PI","TYPE","INPUT","HIDDEN","OUTPUT","NodeGene","type","id","Object","defineProperty","value","writable","PARAMETERS","RandomWeightRange","probGenomeMutateConnectionWeights","probEachWeightUniformPerturb","c1","c2","c3","compatibilityThreshold","addConnectionRate","addNodeRate","cullRate","asexualReproductionRate","elitismRate","mutateToggleEnable","disableGeneInheritingChance","minSpeciesSize","PopulationSize","survivalThreshold","FeedForwardNetwork","genome","network","i","nodes","length","push","neuron","Neuron","incoming","weights","sort","n1","n2","connections","inId","outId","getNeuronIndex","m","idx","activated","calculateNeuronOutput","inNeuron","activateSigmoid","inputs","j","outputs","resetValues","visited","inStack","dfs","Array","fill","exp","max","Genome","species","fitness","connectionCounter","node1","node2","reversed","connectionImpossible","connectionExists","newConnection","getInnovation","addConnection","nodeCounter","connection","getNodeById","newNode","inToNew","newToOut","addNode","node","find","undefined","newConnections","newNodes","copy","newGenome","checkCycles","pop","crossover","parent1","parent2","child","matchingNode","childNodeGene","matchingConnection","getConnection","childConnectionGene","compatibilityDistance","genome1","genome2","N","compatibilities","getGenesCompatibility","excess","disjoint","avgWeightDiff","nodesMatching","connectionMatching","nodegenes1","map","id1","id2","nodegenes2","weightDiff","connectiongenes1","conn1","conn2","connectiongenes2","abs","matching","InnovationGenerator","currentInnovation","reset","Species","representative","members","totalAdjustedFitness","adjustedFitness","g1","g2","splice","killTill","ceil","reproduce","nodeInnovation","connectionInnovation","speciesRemaining","previousSize","s","p","spawnAmounts","computeSpawnAmounts","newPopulation","spawn","Error","oldMembers","g","cutOff","mutateConnectionWeights","addConnectionMutation","addNodeMutation","afSum","reduce","a","b","d","c","round","totalSpawn","norm","speciate","genomes","speciesFound","newSpecies","Evaluator","startingGenome","constructor","populationSize","genomeIdGenerator","initialGenome","randomizeAllWeights","nextGenGenomes","highestScore","fittestGenome","generation","score","evaluateGenome","adjustedScore","addAdjustedFitness","cull","window"],"mappings":"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","file":"neat.js","sourceRoot":"../src","sourcesContent":["export default class ConnectionGene {\n    constructor(inNode, outNode, weight, enabled, innovation) {\n        this.inNode = inNode;\n        this.outNode = outNode;\n        this.weight = weight;\n        this.enabled = enabled;\n        this.innovation = innovation;\n    }\n\n    copy() {\n        return new ConnectionGene(this.inNode, this.outNode, this.weight, this.enabled, this.innovation);\n    }\n};\n","export function randInt(l, r) {\n    return Math.floor(Math.random() * (r - l + 1)) + l;\n}\n\nexport function rand(l, r) {\n    return Math.random() * (r - l) + l;\n}\n\nexport function randGaussian() {\n    var u = 0, v = 0;\n    while(u === 0) u = Math.random(); //Converting [0,1) to (0,1)\n    while(v === 0) v = Math.random();\n    return Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );\n}","const TYPE = {\n    INPUT: 0,\n    HIDDEN: 1,\n    OUTPUT: 2\n};\n\nexport default class NodeGene {\n    constructor(type, id) {\n        this.type = type;\n        this.id = id;\n    }\n\n    copy() {\n        return new NodeGene(this.type, this.id);\n    }\n};\n\nObject.defineProperty(NodeGene, 'TYPE', {\n    value: TYPE,\n    writable: false\n});\n","const PARAMETERS = {\n    RandomWeightRange: 4,\n    probGenomeMutateConnectionWeights: 0.8,\n    probEachWeightUniformPerturb: 0.9,\n    c1: 2,\n    c2: 2,\n    c3: 0.4,\n    compatibilityThreshold: 1.5,\n    addConnectionRate: 0.05,\n    addNodeRate: 0.03,\n    cullRate: 0.6,\n    asexualReproductionRate: 0.25,\n    elitismRate: 0.1,\n    // TODO: implement mutateToggleEnable\n    mutateToggleEnable: 0.3,\n    disableGeneInheritingChance: 0.3,\n    minSpeciesSize: 1,\n    PopulationSize: 50,\n    survivalThreshold: 0.5\n};\n\nexport default PARAMETERS;\n","import NodeGene from \"./node_gene\";\n\n// TODO: implement RNN too!\nexport default class FeedForwardNetwork {\n    constructor(genome) {\n        this.network = [];\n        for(let i=0; i<genome.nodes.length; ++i) {\n            this.network.push({\n                neuron: new Neuron(genome.nodes[i].id, genome.nodes[i].type),\n                incoming: [],\n                weights: []\n            });\n        }\n        this.network.sort((n1, n2) => n1.neuron.id < n2.neuron.id ? -1 : 1);\n        for(let i=0; i < genome.connections.length; ++i) {\n            if(genome.connections[i].enabled) {\n                let inId = genome.connections[i].inNode;\n                let outId = genome.connections[i].outNode;\n                this.network[this.getNeuronIndex(outId)].incoming.push(inId);\n                this.network[this.getNeuronIndex(outId)].weights.push(genome.connections[i].weight);\n            }\n        }\n    }\n\n    // search neuron index in network using binary search\n    getNeuronIndex(id) {\n        let l = 0, r = this.network.length - 1;\n        while(l <= r) {\n            let m = Math.floor((l + r) / 2);\n            if(this.network[m].neuron.id === id) {\n                return m;\n            }\n            else if(this.network[m].neuron.id < id) {\n                l = m + 1;\n            }\n            else {\n                r = m - 1;\n            }\n        }\n    }\n\n    calculateNeuronOutput(id) {\n        let idx = this.getNeuronIndex(id);\n        if(this.network[idx].neuron.activated) {\n            return;\n        }\n\n        for(let i=0; i<this.network[idx].incoming.length; ++i) {\n            this.calculateNeuronOutput(this.network[idx].incoming[i]);\n            let inNeuron = this.network[this.getNeuronIndex(this.network[idx].incoming[i])].neuron;\n            this.network[idx].neuron.value += inNeuron.value * this.network[idx].weights[i];\n        }\n\n        this.network[idx].neuron.activateSigmoid();\n    }\n\n    feed(inputs) {\n        let j = 0;\n        for(let i=0; i<this.network.length; ++i) {\n            if(this.network[i].neuron.type === NodeGene.TYPE.INPUT) {\n                this.network[i].neuron.value = inputs[j];\n                this.network[i].neuron.activated = true;\n                ++j;\n            }\n            if(j === inputs.length)\n                break;\n        }\n\n        let outputs = [];\n        for(let i=0; i<this.network.length; ++i) {\n            if(this.network[i].neuron.type === NodeGene.TYPE.OUTPUT) {\n                this.calculateNeuronOutput(this.network[i].neuron.id);\n                outputs.push(this.network[i].neuron.value);\n            }\n        }\n\n        this.resetValues();\n        return outputs;\n    }\n\n    dfs(u) {\n        let idx = this.getNeuronIndex(u);\n        if(!this.visited[idx]) {\n            this.visited[idx] = true;\n            this.inStack[idx] = true;\n\n            for(let i=0; i<this.network[idx].incoming.length; ++i) {\n                let v = this.network[idx].incoming[i];\n                if(!this.visited[this.getNeuronIndex(v)] && this.dfs(v))\n                    return true;\n                else if(this.inStack[this.getNeuronIndex(v)])\n                    return true;\n            }\n        }\n\n        this.inStack[idx] = false;\n        return false;\n    }\n\n    checkCycles() {\n        this.visited = new Array(this.network.length);\n        this.visited.fill(false);\n        this.inStack = new Array(this.network.length);\n        this.inStack.fill(false);\n        for(let i=0; i<this.network.length; ++i) {\n            if(this.dfs(this.network[i].neuron.id))\n                return true;\n        }\n        \n        return false;\n    }\n\n    resetValues() {\n        for(let i=0; i<this.network.length; ++i) {\n            this.network[i].neuron.value = 0;\n            this.network[i].neuron.activated = false;\n        }\n    }\n};\n\nclass Neuron {\n    constructor(id, type) {\n        this.id = id;\n        this.type = type;\n        this.activated = false;\n        this.value = 0;\n    }\n\n    activateSigmoid() {\n        this.value = 1 / (1 + Math.exp(-this.value));\n        this.activated = true;\n    }\n\n    activateRelu() {\n        this.value = Math.max(this.value, 0);\n        this.activated = true;\n    }\n};\n","import ConnectionGene from './connection_gene';\nimport { randInt, rand, randGaussian } from './helpers';\nimport NodeGene from './node_gene';\nimport PARAMETERS from './parameters';\nimport FeedForwardNetwork from './feed_forward_network';\n\nexport default class Genome {\n    constructor() {\n        this.id = null;\n        this.species = null;\n        this.connections = [];\n        this.nodes = [];\n        this.fitness = 0;\n    }\n\n    // TODO: add tries\n    addConnectionMutation(connectionCounter) {\n        let node1 = this.nodes[randInt(0, this.nodes.length - 1)];\n        let node2 = this.nodes[randInt(0, this.nodes.length - 1)];\n        let weight = rand(-PARAMETERS.RandomWeightRange / 2, PARAMETERS.RandomWeightRange / 2);\n\n        let reversed = false;\n        if(node1.type === NodeGene.TYPE.HIDDEN && node2.type === NodeGene.TYPE.INPUT)\n            reversed = true;\n        else if(node1.type === NodeGene.TYPE.OUTPUT && node2.type === NodeGene.TYPE.HIDDEN)\n            reversed = true;\n        else if(node1.type === NodeGene.TYPE.OUTPUT && node2.type === NodeGene.TYPE.INPUT)\n            reversed = true;\n\n        let connectionImpossible = false;\n        if(node1.type === NodeGene.TYPE.INPUT && node2.type === NodeGene.TYPE.INPUT)\n            connectionImpossible = true;\n        else if(node1.type === NodeGene.TYPE.OUTPUT && node2.type === NodeGene.TYPE.OUTPUT)\n            connectionImpossible = true;\n        else if(node1.id === node2.id)\n            connectionImpossible = true;\n        \n        let connectionExists = false;\n        for(let i=0; i<this.connections.length; ++i) {\n            if(this.connections[i].inNode === node1.id && this.connections[i].outNode === node2.id) {\n                connectionExists = true;\n                break;\n            }\n            if(this.connections[i].inNode === node2.id && this.connections[i].outNode === node1.id) {\n                connectionExists = true;\n                break;\n            }\n        }\n\n        if(connectionExists || connectionImpossible)\n        return;\n        \n        let newConnection = new ConnectionGene(reversed ? node2.id : node1.id, reversed ? node1.id : node2.id, weight, true, connectionCounter.getInnovation());\n        this.addConnection(newConnection);\n    }\n\n    addNodeMutation(nodeCounter, connectionCounter) {\n        let connection = this.connections[randInt(0, this.connections.length - 1)];\n        let inNode = this.getNodeById(connection.inNode);\n        let outNode = this.getNodeById(connection.outNode);\n\n        connection.enabled = false;\n\n        let newNode = new NodeGene(NodeGene.TYPE.HIDDEN, nodeCounter.getInnovation());\n        let inToNew = new ConnectionGene(inNode.id, newNode.id, 1, true, connectionCounter.getInnovation());\n        let newToOut = new ConnectionGene(newNode.id, outNode.id, connection.weight, true, connectionCounter.getInnovation());\n        \n        this.addNode(newNode);\n        this.addConnection(inToNew);\n        this.addConnection(newToOut);\n    }\n\n    mutateConnectionWeights() {\n        for(let i=0; i<this.connections.length; ++i) {\n            if(rand(0, 1) < PARAMETERS.probEachWeightUniformPerturb) {\n                this.connections[i].weight += randGaussian();\n            }\n            else {\n                this.connections[i].weight = rand(-PARAMETERS.RandomWeightRange / 2, PARAMETERS.RandomWeightRange / 2);\n            }\n        }\n    }\n\n    getNodeById(id) {\n        let node =  this.nodes.find(node => node.id === id);\n        if(node === undefined)\n            return null;\n        return node;\n    }\n\n    getConnection(innovation) {\n        let connection = this.connections.find(connection => connection.innovation === innovation);\n        if(connection === undefined)\n            return null;\n        return connection;\n    }\n\n    // TODO: use GenesisGenome\n    randomizeAllWeights() {\n        for(let i=0; i<this.connections.length; ++i) {\n            this.connections[i].weight = rand(-PARAMETERS.RandomWeightRange / 2, PARAMETERS.RandomWeightRange / 2);\n        }\n    }\n\n    copy() {\n        let newConnections = [];\n        let newNodes = [];\n        for(let i=0; i<this.connections.length; ++i)\n            newConnections.push(this.connections[i].copy());\n        for(let i=0; i<this.nodes.length; ++i)\n            newNodes.push(this.nodes[i].copy());\n        \n        let newGenome = new Genome();\n        newGenome.connections = newConnections;\n        newGenome.nodes = newNodes;\n        newGenome.fitness = this.fitness;\n        return newGenome;\n    }\n\n    addNode(node) {\n        this.nodes.push(node);\n    }\n\n    addConnection(connection) {\n        this.connections.push(connection);\n        let net = new FeedForwardNetwork(this);\n        if(!net.checkCycles()) {\n            return true;\n        }\n        else {\n            this.connections.pop();\n            return false;\n        } \n    }\n};\n\n// parent1 should be fitter than parent2\nGenome.crossover = function(parent1, parent2) {\n    let child = new Genome();\n\n    for(let i=0; i<parent1.nodes.length; ++i) {\n        let matchingNode = parent2.getNodeById(parent1.nodes[i].id);\n        if(matchingNode !== null) {\n            let childNodeGene = Math.random() >= 0.5 ? parent1.nodes[i].copy() : matchingNode.copy();\n            child.addNode(childNodeGene);\n        }\n        else {\n            let childNodeGene = parent1.nodes[i].copy();\n            child.addNode(childNodeGene);\n        }\n    }\n    for(let i=0; i<parent1.connections.length; ++i) {\n        let matchingConnection = parent2.getConnection(parent1.connections[i].innovation);\n        let childConnectionGene;\n        if(matchingConnection !== null) {\n            childConnectionGene = Math.random() >= 0.5 ? parent1.connections[i].copy() : matchingConnection.copy();\n            let disabled = !parent1.connections[i].enabled || !matchingConnection.enabled;\n            if(disabled && Math.random() < PARAMETERS.disableGeneInheritingChance)\n                childConnectionGene.enabled = false;\n            child.addConnection(childConnectionGene);\n        }\n        else {\n            childConnectionGene = parent1.connections[i].copy();\n            child.addConnection(childConnectionGene);\n        }\n    }\n    return child;\n}\n\nGenome.compatibilityDistance = function(genome1, genome2) {\n    let N = Math.max(genome1.nodes.length + genome1.connections.length, genome2.nodes.length + genome2.connections.length);\n    let compatibilities = Genome.getGenesCompatibility(genome1, genome2);\n    // TODO: check value of N\n    // N = 1;\n    return (PARAMETERS.c1 * compatibilities.excess / N) + (PARAMETERS.c2 * compatibilities.disjoint / N) + (PARAMETERS.c3 * compatibilities.avgWeightDiff);\n};\n\nGenome.getGenesCompatibility = function(genome1, genome2) {\n    let nodesMatching = 0, connectionMatching = 0, disjoint = 0, excess = 0;\n    // count matching node genes\n    let nodegenes1 = genome1.nodes.map(node => node.id).sort((id1, id2) => id1 < id2 ? -1: 1);\n    let nodegenes2 = genome2.nodes.map(node => node.id).sort((id1, id2) => id1 < id2 ? -1: 1);\n\n    let i = nodegenes1.length - 1;\n    let j = nodegenes2.length - 1;\n    while(i >= 0 && j >= 0) {\n        if(nodegenes1[i] === nodegenes2[j]) {\n            ++nodesMatching;\n            --i;\n            --j;\n        }\n        else {\n            if(nodegenes1[i] < nodegenes2[j]) {\n                if(nodegenes2[j] > nodegenes1[nodegenes1.length - 1])\n                    ++excess;\n                else\n                    ++disjoint;\n                --j;\n            }\n            else {\n                if(nodegenes1[i] > nodegenes2[nodegenes2.length - 1])\n                    ++excess;\n                else\n                    ++disjoint;\n                --i;\n            }\n        }\n    }\n\n    // count matching connection genes\n    let weightDiff = 0;\n    let connectiongenes1 = genome1.connections.map(connection => { return { innovation : connection.innovation, weight: connection.weight } })\n                                              .sort((conn1, conn2) => conn1.innovation < conn2.innovation ? -1: 1);\n    let connectiongenes2 = genome2.connections.map(connection => { return { innovation : connection.innovation, weight: connection.weight } })\n                                              .sort((conn1, conn2) => conn1.innovation < conn2.innovation ? -1: 1);\n\n    i = connectiongenes1.length - 1;\n    j = connectiongenes2.length - 1;\n    while(i >= 0 && j >= 0) {\n        if(connectiongenes1[i].innovation === connectiongenes2[j].innovation) {\n            ++connectionMatching;\n            weightDiff += Math.abs(connectiongenes1[i].weight - connectiongenes2[j].weight);\n            --i;\n            --j;\n        }\n        else {\n            if(connectiongenes1[i].innovation < connectiongenes2[j].innovation) {\n                if(connectiongenes2[j].innovation > connectiongenes1[connectiongenes1.length - 1].innovation)\n                    ++excess;\n                else\n                    ++disjoint;\n                --j;\n            }\n            else {\n                if(connectiongenes1[i].innovation > connectiongenes2[connectiongenes2.length - 1].innovation)\n                    ++excess;\n                else\n                    ++disjoint;\n                --i;\n            }\n        }\n    }\n    let avgWeightDiff = connectionMatching > 0 ? weightDiff / connectionMatching : 0;\n    return {\n        matching: nodesMatching + connectionMatching,\n        disjoint: disjoint,\n        excess: excess,\n        avgWeightDiff: avgWeightDiff\n    };\n}\n","export default class InnovationGenerator {\n    constructor() {\n        let currentInnovation = -1;\n\n        this.getInnovation = function() {\n            ++ currentInnovation;\n            return currentInnovation;\n        };\n\n        this.reset = function() {\n            currentInnovation = -1;\n        };\n    }\n}","import { randInt } from \"./helpers\";\nimport PARAMETERS from \"./parameters\";\nimport Genome from \"./genome\";\n\n// TODO: set compatibility threshold dynamically to make no of species remain constant\nexport default class Species {\n    constructor(representative) {\n        this.representative = representative;\n        this.members = [representative];\n        this.totalAdjustedFitness = 0;\n    }\n\n    addAdjustedFitness(adjustedFitness) {\n        this.totalAdjustedFitness += adjustedFitness;\n    }\n\n    reset() {\n        this.members.sort((g1, g2) => g1.fitness > g2.fitness ? -1: 1);\n        this.representative = this.members[0];\n        this.members.splice(0, this.members.length);\n        this.totalAdjustedFitness = 0;\n    }\n\n    cull() {\n        this.members.sort((g1, g2) => g1.fitness > g2.fitness ? -1: 1);\n        let killTill = Math.ceil(this.members.length * (1 - PARAMETERS.cullRate));\n        for(let i = this.members.length; i >= killTill; --i) {\n            this.members.splice(i, 1);\n        }\n    }\n};\n\n\nSpecies.reproduce = function(species, nodeInnovation, connectionInnovation) {\n    // TODO: implement stagnation\n    let speciesRemaining = [...species];\n    let previousSize = speciesRemaining.map(s => s.members.length);\n    let minSpeciesSize = previousSize.map(p => Math.max(PARAMETERS.elitismRate * p, PARAMETERS.minSpeciesSize));\n    let adjustedFitness = speciesRemaining.map(s => s.totalAdjustedFitness);\n\n    let spawnAmounts = Species.computeSpawnAmounts(previousSize, minSpeciesSize, adjustedFitness);\n\n    let newPopulation = [];\n    // console.log(previousSize, minSpeciesSize, adjustedFitness, spawnAmounts);\n    \n    for(let i=0; i<speciesRemaining.length; ++i) {\n        let s = speciesRemaining[i];\n        let spawn = Math.max(previousSize[i] * PARAMETERS.elitismRate, spawnAmounts[i]);\n        if(spawn < 0)\n            throw new Error(\"Spawning should be positive\");\n        \n        let oldMembers = s.members.map(g => g.copy());\n\n        oldMembers.sort((g1, g2) => g1.fitness > g2.fitness ? -1: 1);\n        for(let j=0; j<Math.ceil(s.members.length * PARAMETERS.elitismRate); ++j) {\n            newPopulation.push(s.members[j]);\n            --spawn;\n        }\n\n        if(spawn <= 0)\n            continue;\n\n        let cutOff = Math.ceil(PARAMETERS.survivalThreshold * oldMembers.length);\n        if(oldMembers.length > 1)\n           cutOff = Math.max(2, cutOff);\n        while(cutOff < oldMembers.length) {\n            oldMembers.pop();\n        }\n\n        while(spawn > 0) {\n            spawn -= 1;\n\n            let id1 = randInt(0, oldMembers.length - 1);\n            let id2 = randInt(0, oldMembers.length - 1);\n            let parent1 = oldMembers[id1];\n            let parent2 = oldMembers[id2];\n            let child;\n            \n            if(Math.random() > PARAMETERS.asexualReproductionRate && id1 !== id2) {\n                if(parent1.fitness > parent2.fitness) {\n                    child = Genome.crossover(parent1, parent2);\n                }\n                else {\n                    child = Genome.crossover(parent2, parent1);\n                }\n                if(Math.random() < PARAMETERS.probGenomeMutateConnectionWeights)\n                    child.mutateConnectionWeights();\n                if(Math.random() < PARAMETERS.addConnectionRate)\n                    child.addConnectionMutation(connectionInnovation);\n                if(Math.random() < PARAMETERS.addNodeRate)\n                    child.addNodeMutation(nodeInnovation, connectionInnovation);\n            }\n            else {\n                child = parent1.copy();\n                if(Math.random() < PARAMETERS.probGenomeMutateConnectionWeights)\n                    child.mutateConnectionWeights();\n            }\n\n            newPopulation.push(child);\n        }\n    }\n    return newPopulation;\n};\n\nSpecies.computeSpawnAmounts = function(previousSize, minSpeciesSize, adjustedFitness) {\n    let afSum = adjustedFitness.reduce((a, b) => a + b, 0);\n    let spawnAmounts = [];\n\n    for(let i=0; i<adjustedFitness.length; ++i) {\n        let s = Math.max(minSpeciesSize[i], (adjustedFitness[i] / afSum) * PARAMETERS.PopulationSize);\n        // TODO: check why / 2\n        let d = (s - previousSize[i]) / 2;\n        let c = Math.round(d);\n        \n        let spawn = previousSize[i];\n        if(Math.abs(c) > 0)\n            spawn += c;\n        else if(d > 0)\n            spawn += 1;\n        else\n            spawn -= 1;\n\n        spawnAmounts.push(spawn);\n    }\n    let totalSpawn = spawnAmounts.reduce((a, b) => a + b, 0);\n    let norm = PARAMETERS.PopulationSize / totalSpawn;\n    spawnAmounts = spawnAmounts.map((s, i) => Math.max(minSpeciesSize[i], Math.round(norm * s)));\n    // spawnAmounts = spawnAmounts.map((s, i) => Math.round(norm * s));\n\n    return spawnAmounts;\n};\n\nSpecies.speciate = function(species, genomes) {\n    // Place genomes into species\n    for(let i=0; i<species.length; ++i)\n        species[i].reset();\n        \n    for(let i=0; i<genomes.length; ++i) {\n        let speciesFound = false;\n        for(let j=0; j<species.length; ++j) {\n            if(Genome.compatibilityDistance(genomes[i], species[j].representative) < PARAMETERS.compatibilityThreshold) {\n                species[j].members.push(genomes[i]);\n                speciesFound = true;\n                genomes[i].species = j;\n                break;\n            }\n        }\n        if(!speciesFound) {\n            let newSpecies = new Species(genomes[i]);\n            species.push(newSpecies);\n            genomes[i].species = species.length - 1;\n        }\n    }\n\n    return species;\n};\n","import Species from './species';\nimport Genome from './genome';\nimport PARAMETERS from './parameters';\nimport InnovationGenerator from './innovation_generator';\n\nexport default class Evaluator {\n    constructor(startingGenome, connectionInnovation, nodeInnovation) {\n        if(this.constructor === Evaluator) {\n            throw new Error(\"Evaluator cannot be instantiated\");\n        }\n\n        this.populationSize = PARAMETERS.PopulationSize;\n        this.genomeIdGenerator = new InnovationGenerator();\n        this.genomes = [];\n        for(let i=0; i<this.populationSize; ++i) {\n            let initialGenome = startingGenome.copy();\n            initialGenome.id = this.genomeIdGenerator.getInnovation();\n            initialGenome.randomizeAllWeights();\n            this.genomes.push(initialGenome);\n        }\n        this.nextGenGenomes = [];\n        this.species = [];\n\n        this.connectionInnovation = connectionInnovation;\n        this.nodeInnovation = nodeInnovation;\n\n        this.highestScore = 0;\n        this.fittestGenome;\n\n        this.generation = 0;\n\n        // Place genomes into species\n        this.species = Species.speciate(this.species, this.genomes);\n    }\n\n    evaluate() {\n        // reset everything for next generation\n        this.nextGenGenomes = [];\n        this.fittestGenome = null;\n        this.highestScore = 0;\n        this.genomeIdGenerator.reset();\n\n        // Evaluate genomes and assign fitness\n        for(let i=0; i<this.species.length; ++i) {\n            for(let j=0; j<this.species[i].members.length; ++j) {\n                let s = this.species[i];\n                let g = this.species[i].members[j];\n\n                let score = this.evaluateGenome(g);\n                let adjustedScore = score / s.members.length;\n                s.addAdjustedFitness(adjustedScore);\n                g.fitness = adjustedScore;\n                if(score > this.highestScore) {\n                    this.highestScore = score;\n                    this.fittestGenome = g;\n                }\n            }\n        }\n\n\n        // Cull genome in each Species\n        for(let i=0; i<this.species.length; ++i) {\n            this.species[i].cull();\n        }\n\n        // remove empty species\n        for(let i=this.species.length - 1; i >= 0; --i) {\n            if(this.species[i].members.length === 0) {\n                this.species.splice(i, 1);\n            }\n        }\n\n        // breed rest of the genomes\n        this.nextGenGenomes = Species.reproduce(this.species, this.nodeInnovation, this.connectionInnovation);\n\n        this.genomes = [...this.nextGenGenomes];\n        for(let i=0; i<this.genomes.length; ++i)\n            this.genomes[i].id = this.genomeIdGenerator.getInnovation();\n        this.populationSize = this.genomes.length;\n\n        ++this.generation;\n\n        // Place genomes into species\n        this.species = Species.speciate(this.species, this.genomes);\n    }\n\n    evaluateGenome(genome) {\n        throw new Error(\"Method evaluateGenome() must be implemented\");\n    }\n    \n};\n","import Genome from './genome';\nimport InnovationGenerator from './innovation_generator';\nimport NodeGene from './node_gene';\nimport ConnectionGene from './connection_gene';\nimport Evaluator from './evaluator';\nimport FeedForwardNetwork from './feed_forward_network';\n\nwindow.Genome = Genome;\nwindow.NodeGene = NodeGene;\nwindow.ConnectionGene = ConnectionGene;\nwindow.InnovationGenerator = InnovationGenerator;\nwindow.Evaluator = Evaluator;\nwindow.FeedForwardNetwork = FeedForwardNetwork;"]}