{"version":3,"sources":["connection_gene.js","helpers.js","node_gene.js","parameters.js","genome.js","innovation_generator.js","species.js","evaluator.js","neat.js"],"names":["ConnectionGene","inNode","outNode","weight","enabled","innovation","randInt","l","r","Math","floor","random","rand","TYPE","INPUT","HIDDEN","OUTPUT","NodeGene","type","id","Object","defineProperty","value","writable","PARAMETERS","RandomWeightRange","probGenomeMutateConnectionWeights","probEachWeightUniformPerturb","c1","c2","c3","compatibilityThreshold","addConnectionRate","addNodeRate","Genome","connections","nodes","fitness","connectionCounter","node1","length","node2","reversed","connectionImpossible","connectionExists","i","newConnection","getInnovation","push","nodeCounter","connection","getNodeById","newNode","inToNew","newToOut","node","find","undefined","newConnections","newNodes","copy","newGenome","crossover","parent1","parent2","child","matchingNode","childNodeGene","matchingConnection","getConnection","childConnectionGene","compatibilityDistance","genome1","genome2","N","max","compatibilities","getGenesCompatibility","excess","disjoint","avgWeightDiff","nodesMatching","connectionMatching","nodegenes1","map","sort","id1","id2","nodegenes2","j","weightDiff","connectiongenes1","conn1","conn2","connectiongenes2","abs","matching","InnovationGenerator","currentInnovation","Species","representative","members","totalAdjustedFitness","adjustedFitness","splice","Evaluator","startingGenome","populationSize","connectionInnovation","nodeInnovation","constructor","Error","genomes","nextGenGenomes","speciesMap","species","highestScore","fittestGenome","reset","speciesFound","genome","newSpecies","g","s","score","evaluateGenome","adjustedScore","addAdjustedFitness","g1","g2","getRandomSpeciesBiasedAdjustedFitness","getRandomGenomeBiasedAdjustedFitness","mutateConnectionWeights","addConnectionMutation","addNodeMutation","completeWeight","countWeight","fromSpecies","window"],"mappings":"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","file":"neat.js","sourceRoot":"../src","sourcesContent":["export default class ConnectionGene {\n    constructor(inNode, outNode, weight, enabled, innovation) {\n        this.inNode = inNode;\n        this.outNode = outNode;\n        this.weight = weight;\n        this.enabled = enabled;\n        this.innovation = innovation;\n    }\n\n    copy() {\n        return new ConnectionGene(this.inNode, this.outNode, this.weight, this.enabled, this.innovation);\n    }\n};\n","export function randInt(l, r) {\n    return Math.floor(Math.random() * (r - l + 1)) + l;\n}\n\nexport function rand(l, r) {\n    return Math.random() * (r - l) + l;\n}\n","const TYPE = {\n    INPUT: 0,\n    HIDDEN: 1,\n    OUTPUT: 2\n};\n\nexport default class NodeGene {\n    constructor(type, id) {\n        this.type = type;\n        this.id = id;\n    }\n\n    copy() {\n        return new NodeGene(this.type, this.id);\n    }\n};\n\nObject.defineProperty(NodeGene, 'TYPE', {\n    value: TYPE,\n    writable: false\n});\n","const PARAMETERS = {\n    RandomWeightRange: 4,\n    probGenomeMutateConnectionWeights: 0.8,\n    probEachWeightUniformPerturb: 0.9,\n    c1: 1,\n    c2: 1,\n    c3: 0.4,\n    compatibilityThreshold: 13,\n    addConnectionRate: 0.5,\n    addNodeRate: 0.5\n};\n\nexport default PARAMETERS;\n","import ConnectionGene from './connection_gene';\nimport { randInt, rand } from './helpers';\nimport NodeGene from './node_gene';\nimport PARAMETERS from './parameters';\n\nexport default class Genome {\n    constructor() {\n        this.connections = [];\n        this.nodes = [];\n        this.fitness = 0;\n    }\n\n    // TODO: add tries\n    addConnectionMutation(connectionCounter) {\n        let node1 = this.nodes[randInt(0, this.nodes.length - 1)];\n        let node2 = this.nodes[randInt(0, this.nodes.length - 1)];\n        let weight = rand(-PARAMETERS.RandomWeightRange / 2, PARAMETERS.RandomWeightRange / 2);\n\n        let reversed = false;\n        if(node1.type === NodeGene.TYPE.HIDDEN && node2.type === NodeGene.TYPE.INPUT)\n            reversed = true;\n        else if(node1.type === NodeGene.TYPE.OUTPUT && node2.type === NodeGene.TYPE.HIDDEN)\n            reversed = true;\n        else if(node1.type === NodeGene.TYPE.OUTPUT && node2.type === NodeGene.TYPE.INPUT)\n            reversed = true;\n\n        let connectionImpossible = false;\n        if(node1.type === NodeGene.TYPE.INPUT && node2.type === NodeGene.TYPE.INPUT)\n            connectionImpossible = true;\n        else if(node1.type === NodeGene.TYPE.OUTPUT && node2.type === NodeGene.TYPE.OUTPUT)\n            connectionImpossible = true;\n        else if(node1.id === node2.id)\n            connectionImpossible = true;\n        \n        let connectionExists = false;\n        for(let i=0; i<this.connections.length; ++i) {\n            if(this.connections[i].inNode === node1.id && this.connections[i].outNode === node2.id) {\n                connectionExists = true;\n                break;\n            }\n            if(this.connections[i].inNode === node2.id && this.connections[i].outNode === node1.id) {\n                connectionExists = true;\n                break;\n            }\n        }\n\n        if(connectionExists || connectionImpossible)\n        return;\n        \n        let newConnection = new ConnectionGene(reversed ? node2.id : node1.id, reversed ? node1.id : node2.id, weight, true, connectionCounter.getInnovation());\n        this.connections.push(newConnection);\n    }\n\n    addNodeMutation(nodeCounter, connectionCounter) {\n        let connection = this.connections[randInt(0, this.connections.length - 1)];\n        let inNode = this.getNodeById(connection.inNode);\n        let outNode = this.getNodeById(connection.outNode);\n\n        connection.enabled = false;\n\n        let newNode = new NodeGene(NodeGene.TYPE.HIDDEN, nodeCounter.getInnovation());\n        let inToNew = new ConnectionGene(inNode.id, newNode.id, 1, true, connectionCounter.getInnovation());\n        let newToOut = new ConnectionGene(newNode.id, outNode.id, connection.weight, true, connectionCounter.getInnovation());\n        \n        this.nodes.push(newNode);\n        this.connections.push(inToNew);\n        this.connections.push(newToOut);\n    }\n\n    mutateConnectionWeights() {\n        for(let i=0; i<this.connections.length; ++i) {\n            if(rand(0, 1) < PARAMETERS.probEachWeightUniformPerturb) {\n                this.connections[i].weight *= rand(-PARAMETERS.RandomWeightRange / 2, PARAMETERS.RandomWeightRange / 2);\n            }\n            else {\n                this.connections[i].weight = rand(-PARAMETERS.RandomWeightRange / 2, PARAMETERS.RandomWeightRange / 2);\n            }\n        }\n    }\n\n    getNodeById(id) {\n        let node =  this.nodes.find(node => node.id === id);\n        if(node === undefined)\n            return null;\n        return node;\n    }\n\n    getConnection(innovation) {\n        let connection = this.connections.find(connection => connection.innovation === innovation);\n        if(connection === undefined)\n            return null;\n        return connection;\n    }\n\n    copy() {\n        let newConnections = [];\n        let newNodes = [];\n        for(let i=0; i<this.connections.length; ++i)\n            newConnections.push(this.connections[i].copy());\n        for(let i=0; i<this.nodes.length; ++i)\n            newNodes.push(this.nodes[i].copy());\n        \n        let newGenome = new Genome();\n        newGenome.connections = newConnections;\n        newGenome.nodes = newNodes;\n        newGenome.fitness = this.fitness;\n        return newGenome;\n    }\n};\n\n// parent1 should be fitter than parent2\nGenome.crossover = function(parent1, parent2) {\n    let child = new Genome();\n\n    for(let i=0; i<parent1.nodes.length; ++i) {\n        let matchingNode = parent2.getNodeById(parent1.nodes[i].id);\n        if(matchingNode !== null) {\n            let childNodeGene = Math.random() >= 0.5 ? parent1.nodes[i].copy() : matchingNode.copy();\n            child.nodes.push(childNodeGene);\n        }\n        else {\n            let childNodeGene = parent1.nodes[i].copy();\n            child.nodes.push(childNodeGene);\n        }\n    }\n    for(let i=0; i<parent1.connections.length; ++i) {\n        let matchingConnection = parent2.getConnection(parent1.connections[i].innovation);\n        let childConnectionGene;\n        if(matchingConnection !== null) {\n            childConnectionGene = Math.random() >= 0.5 ? parent1.connections[i].copy() : matchingConnection.copy();\n            child.connections.push(childConnectionGene);\n        }\n        else {\n            childConnectionGene = parent1.connections[i].copy();\n            child.connections.push(childConnectionGene);\n        }\n    }\n    return child;\n}\n\nGenome.compatibilityDistance = function(genome1, genome2) {\n    let N = Math.max(genome1.nodes.length + genome1.connections.length, genome2.nodes.length + genome2.connections.length);\n    let compatibilities = Genome.getGenesCompatibility(genome1, genome2);\n    return PARAMETERS.c1 * compatibilities.excess / N + PARAMETERS.c2 * compatibilities.disjoint / N + PARAMETERS.c3 * compatibilities.avgWeightDiff;\n};\n\nGenome.getGenesCompatibility = function(genome1, genome2) {\n    let nodesMatching = 0, connectionMatching = 0, disjoint = 0, excess = 0;\n    // count matching node genes\n    let nodegenes1 = genome1.nodes.map(node => node.id).sort((id1, id2) => id1 < id2 ? -1: 1);\n    let nodegenes2 = genome2.nodes.map(node => node.id).sort((id1, id2) => id1 < id2 ? -1: 1);\n\n    let i = nodegenes1.length - 1;\n    let j = nodegenes2.length - 1;\n    while(i >= 0 && j >= 0) {\n        if(nodegenes1[i] === nodegenes2[j]) {\n            ++nodesMatching;\n            --i;\n            --j;\n        }\n        else {\n            if(nodegenes1[i] < nodegenes2[j]) {\n                if(nodegenes2[j] > nodegenes1[nodegenes1.length - 1])\n                    ++excess;\n                else\n                    ++disjoint;\n                --j;\n            }\n            else {\n                if(nodegenes1[i] > nodegenes2[nodegenes2.length - 1])\n                    ++excess;\n                else\n                    ++disjoint;\n                --i;\n            }\n        }\n    }\n\n    // count matching connection genes\n    let weightDiff = 0;\n    let connectiongenes1 = genome1.connections.map(connection => { return { innovation : connection.innovation, weight: connection.weight } })\n                                              .sort((conn1, conn2) => conn1.innovation < conn2.innovation ? -1: 1);\n    let connectiongenes2 = genome2.connections.map(connection => { return { innovation : connection.innovation, weight: connection.weight } })\n                                              .sort((conn1, conn2) => conn1.innovation < conn2.innovation ? -1: 1);\n\n    i = connectiongenes1.length - 1;\n    j = connectiongenes2.length - 1;\n    while(i >= 0 && j >= 0) {\n        if(connectiongenes1[i].innovation === connectiongenes2[j].innovation) {\n            ++connectionMatching;\n            weightDiff += Math.abs(connectiongenes1[i].weight - connectiongenes2[j].weight);\n            --i;\n            --j;\n        }\n        else {\n            if(connectiongenes1[i].innovation < connectiongenes2[j].innovation) {\n                if(connectiongenes2[j].innovation > connectiongenes1[connectiongenes1.length - 1].innovation)\n                    ++excess;\n                else\n                    ++disjoint;\n                --j;\n            }\n            else {\n                if(connectiongenes1[i].innovation > connectiongenes2[connectiongenes2.length - 1].innovation)\n                    ++excess;\n                else\n                    ++disjoint;\n                --i;\n            }\n        }\n    }\n\n    return {\n        matching: nodesMatching + connectionMatching,\n        disjoint: disjoint,\n        excess: excess,\n        avgWeightDiff: weightDiff / connectionMatching\n    };\n}\n","export default class InnovationGenerator {\n    constructor() {\n        let currentInnovation = -1;\n\n        this.getInnovation = function() {\n            ++ currentInnovation;\n            return currentInnovation;\n        };  \n    }\n}","import { randInt } from \"./helpers\";\n\nexport default class Species {\n    constructor(representative) {\n        this.representative = representative;\n        this.members = [representative];\n        this.totalAdjustedFitness = 0;\n    }\n\n    addAdjustedFitness(adjustedFitness) {\n        this.totalAdjustedFitness += adjustedFitness;\n    }\n\n    reset() {\n        this.representative = this.members[randInt(0, this.members.length - 1)];\n        this.members.splice(0, this.members.length);\n        this.totalAdjustedFitness = 0;\n    }\n};","import Species from './species';\nimport Genome from './genome';\nimport PARAMETERS from './parameters';\n\nexport default class Evaluator {\n    constructor(startingGenome, populationSize, connectionInnovation, nodeInnovation) {\n        if(this.constructor === Evaluator) {\n            throw new Error(\"Evaluator cannot be instantiated\");\n        }\n\n        this.populationSize = populationSize;\n        this.genomes = [];\n        for(let i=0; i<populationSize; ++i)\n            this.genomes.push(startingGenome.copy());\n        this.nextGenGenomes = [];\n        this.speciesMap = [];\n        this.species = [];\n\n        this.connectionInnovation = connectionInnovation;\n        this.nodeInnovation = nodeInnovation;\n\n        this.highestScore = 0;\n        this.fittestGenome;\n    }\n\n    evaluate() {\n        // reset everything for next generation\n        for(let i=0; i<this.species.length; ++i)\n            this.species[i].reset();\n        this.speciesMap.splice(0, this.speciesMap.length);\n        this.nextGenGenomes = [];\n        this.fittestGenome = null;\n        this.highestScore = 0;\n\n        // Place genomes into species\n        for(let i=0; i<this.genomes.length; ++i) {\n            let speciesFound = false;\n            for(let j=0; j<this.species.length; ++j) {\n                if(Genome.compatibilityDistance(this.genomes[i], this.species[j].representative) < PARAMETERS.compatibilityThreshold) {\n                    this.species[j].members.push(this.genomes[i]);\n                    this.speciesMap.push({\n                        genome: this.genomes[i],\n                        species: this.species[j]\n                    });\n                    speciesFound = true;\n                    break;\n                }\n            }\n            if(!speciesFound) {\n                let newSpecies = new Species(this.genomes[i]);\n                this.species.push(newSpecies);\n                this.speciesMap.push({\n                    genome: this.genomes[i],\n                    species: newSpecies\n                });\n            }\n        }\n        \n        // remove empty species\n        for(let i=this.species.length - 1; i >= 0; --i) {\n            if(this.species[i].members.length === 0) {\n                this.species.splice(i, 1);\n            }\n        }\n\n        // Evaluate genomes and assign fitness\n        for(let i=0; i<this.speciesMap.length; ++i) {\n            let g = this.speciesMap[i].genome;\n            let s = this.speciesMap[i].species;\n\n            let score = this.evaluateGenome(g);\n            let adjustedScore = score / s.members.length;\n            s.addAdjustedFitness(adjustedScore);\n            g.fitness = adjustedScore;\n            if(score > this.highestScore) {\n                this.highestScore = score;\n                this.fittestGenome = g;\n            }\n        }\n\n        // Put best genomes from each species into next generation\n        for(let i=0; i<this.species.length; ++i) {\n            this.species[i].members.sort((g1, g2) => g1.fitness > g2.fitness ? -1: 1);\n            let fittestGenome = this.species[i].members[0].copy();\n            this.nextGenGenomes.push(fittestGenome);\n        }\n\n        // Breed the rest of the genomes\n        while(this.nextGenGenomes.length < this.populationSize) {\n            let s = this.getRandomSpeciesBiasedAdjustedFitness();\n            let g1 = this.getRandomGenomeBiasedAdjustedFitness(s);\n            let g2 = this.getRandomGenomeBiasedAdjustedFitness(s);\n            let child;\n            if(g1.fitness > g2.fitness) {\n                child = Genome.crossover(g1, g2);\n            }\n            else {\n                child = Genome.crossover(g2, g1);\n            }\n\n            if(Math.random() < PARAMETERS.probGenomeMutateConnectionWeights)\n                child.mutateConnectionWeights();\n            if(Math.random() < PARAMETERS.addConnectionRate)\n                child.addConnectionMutation(this.connectionInnovation);\n            if(Math.random() < PARAMETERS.addNodeRate)\n                child.addNodeMutation(this.nodeInnovation, this.connectionInnovation);\n\n            this.nextGenGenomes.push(child);\n        }\n\n        this.genomes = [...this.nextGenGenomes];\n    }\n\n    getRandomSpeciesBiasedAdjustedFitness() {\n        let completeWeight = 0;\n        for(let i=0; i<this.species.length; ++i) {\n            completeWeight += this.species[i].totalAdjustedFitness;\n        }\n\n        let r = Math.random() * completeWeight;\n        let countWeight = 0;\n        for(let i=0; i<this.species.length; ++i) {\n            countWeight += this.species[i].totalAdjustedFitness;\n            if(countWeight >= r) {\n                return this.species[i];\n            }\n        }\n        throw new Error(\"Couldn't find a species\");\n    }\n\n    getRandomGenomeBiasedAdjustedFitness(fromSpecies) {\n        let completeWeight = 0;\n        for(let i=0; i<fromSpecies.members.length; ++i) {\n            completeWeight += fromSpecies.members[i].fitness;\n        }\n\n        let r = Math.random() * completeWeight;\n        let countWeight = 0;\n        for(let i=0; i<fromSpecies.members.length; ++i) {\n            countWeight += fromSpecies.members[i].fitness;\n            if(countWeight >= r) {\n                return fromSpecies.members[i];\n            }\n        }\n        throw new Error(\"Couldn't find a genome\");\n    }\n\n    evaluateGenome(genome) {\n        throw new Error(\"Method evaluateGenome() must be implemented\");\n    }\n    \n};\n","import Genome from './genome';\nimport InnovationGenerator from './innovation_generator';\nimport NodeGene from './node_gene';\nimport ConnectionGene from './connection_gene';\nimport Evaluator from './evaluator';\n\nwindow.Genome = Genome;\nwindow.NodeGene = NodeGene;\nwindow.ConnectionGene = ConnectionGene;\nwindow.InnovationGenerator = InnovationGenerator;\nwindow.Evaluator = Evaluator;"]}