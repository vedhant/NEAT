{"id":"evaluator.js","dependencies":[{"name":"/home/vedhant/ml/neat/package.json","includedInParent":true,"mtime":1571574106382},{"name":"./species","loc":{"line":1,"column":20},"parent":"/home/vedhant/ml/neat/src/evaluator.js","resolved":"/home/vedhant/ml/neat/src/species.js"},{"name":"./genome","loc":{"line":2,"column":19},"parent":"/home/vedhant/ml/neat/src/evaluator.js","resolved":"/home/vedhant/ml/neat/src/genome.js"},{"name":"./parameters","loc":{"line":3,"column":23},"parent":"/home/vedhant/ml/neat/src/evaluator.js","resolved":"/home/vedhant/ml/neat/src/parameters.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _species = _interopRequireDefault(require(\"./species\"));\n\nvar _genome = _interopRequireDefault(require(\"./genome\"));\n\nvar _parameters = _interopRequireDefault(require(\"./parameters\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Evaluator =\n/*#__PURE__*/\nfunction () {\n  function Evaluator(startingGenome, populationSize, connectionInnovation, nodeInnovation) {\n    _classCallCheck(this, Evaluator);\n\n    if (this.constructor === Evaluator) {\n      throw new Error(\"Evaluator cannot be instantiated\");\n    }\n\n    this.populationSize = populationSize;\n    this.genomes = [];\n\n    for (var i = 0; i < populationSize; ++i) {\n      this.genomes.push(startingGenome.copy());\n    }\n\n    this.nextGenGenomes = [];\n    this.speciesMap = [];\n    this.species = [];\n    this.connectionInnovation = connectionInnovation;\n    this.nodeInnovation = nodeInnovation;\n    this.highestScore = 0;\n    this.fittestGenome;\n  }\n\n  _createClass(Evaluator, [{\n    key: \"evaluate\",\n    value: function evaluate() {\n      // reset everything for next generation\n      for (var i = 0; i < this.species.length; ++i) {\n        this.species[i].reset();\n      }\n\n      this.speciesMap.splice(0, this.speciesMap.length);\n      this.nextGenGenomes = [];\n      this.fittestGenome = null;\n      this.highestScore = 0; // Place genomes into species\n\n      for (var _i = 0; _i < this.genomes.length; ++_i) {\n        var speciesFound = false;\n\n        for (var j = 0; j < this.species.length; ++j) {\n          if (_genome.default.compatibilityDistance(this.genomes[_i], this.species[j].representative) < _parameters.default.compatibilityThreshold) {\n            this.species[j].members.push(this.genomes[_i]);\n            this.speciesMap.push({\n              genome: this.genomes[_i],\n              species: this.species[j]\n            });\n            speciesFound = true;\n            break;\n          }\n        }\n\n        if (!speciesFound) {\n          var newSpecies = new _species.default(this.genomes[_i]);\n          this.species.push(newSpecies);\n          this.speciesMap.push({\n            genome: this.genomes[_i],\n            species: newSpecies\n          });\n        }\n      } // remove empty species\n\n\n      for (var _i2 = this.species.length - 1; _i2 >= 0; --_i2) {\n        if (this.species[_i2].members.length === 0) {\n          this.species.splice(_i2, 1);\n        }\n      } // Evaluate genomes and assign fitness\n\n\n      for (var _i3 = 0; _i3 < this.speciesMap.length; ++_i3) {\n        var g = this.speciesMap[_i3].genome;\n        var s = this.speciesMap[_i3].species;\n        var score = this.evaluateGenome(g);\n        var adjustedScore = score / s.members.length;\n        s.addAdjustedFitness(adjustedScore);\n        g.fitness = adjustedScore;\n\n        if (score > this.highestScore) {\n          this.highestScore = score;\n          this.fittestGenome = g;\n        }\n      } // Put best genomes from each species into next generation\n\n\n      for (var _i4 = 0; _i4 < this.species.length; ++_i4) {\n        this.species[_i4].members.sort(function (g1, g2) {\n          return g1.fitness > g2.fitness ? -1 : 1;\n        });\n\n        var fittestGenome = this.species[_i4].members[0].copy();\n\n        this.nextGenGenomes.push(fittestGenome);\n      } // Breed the rest of the genomes\n\n\n      while (this.nextGenGenomes.length < this.populationSize) {\n        var _s = this.getRandomSpeciesBiasedAdjustedFitness();\n\n        var g1 = this.getRandomGenomeBiasedAdjustedFitness(_s);\n        var g2 = this.getRandomGenomeBiasedAdjustedFitness(_s);\n        var child = void 0;\n\n        if (g1.fitness > g2.fitness) {\n          child = _genome.default.crossover(g1, g2);\n        } else {\n          child = _genome.default.crossover(g2, g1);\n        }\n\n        if (Math.random() < _parameters.default.probGenomeMutateConnectionWeights) child.mutateConnectionWeights();\n        if (Math.random() < _parameters.default.addConnectionRate) child.addConnectionMutation(this.connectionInnovation);\n        if (Math.random() < _parameters.default.addNodeRate) child.addNodeMutation(this.nodeInnovation, this.connectionInnovation);\n        this.nextGenGenomes.push(child);\n      }\n\n      this.genomes = _toConsumableArray(this.nextGenGenomes);\n    }\n  }, {\n    key: \"getRandomSpeciesBiasedAdjustedFitness\",\n    value: function getRandomSpeciesBiasedAdjustedFitness() {\n      var completeWeight = 0;\n\n      for (var i = 0; i < this.species.length; ++i) {\n        completeWeight += this.species[i].totalAdjustedFitness;\n      }\n\n      var r = Math.random() * completeWeight;\n      var countWeight = 0;\n\n      for (var _i5 = 0; _i5 < this.species.length; ++_i5) {\n        countWeight += this.species[_i5].totalAdjustedFitness;\n\n        if (countWeight >= r) {\n          return this.species[_i5];\n        }\n      }\n\n      throw new Error(\"Couldn't find a species\");\n    }\n  }, {\n    key: \"getRandomGenomeBiasedAdjustedFitness\",\n    value: function getRandomGenomeBiasedAdjustedFitness(fromSpecies) {\n      var completeWeight = 0;\n\n      for (var i = 0; i < fromSpecies.members.length; ++i) {\n        completeWeight += fromSpecies.members[i].fitness;\n      }\n\n      var r = Math.random() * completeWeight;\n      var countWeight = 0;\n\n      for (var _i6 = 0; _i6 < fromSpecies.members.length; ++_i6) {\n        countWeight += fromSpecies.members[_i6].fitness;\n\n        if (countWeight >= r) {\n          return fromSpecies.members[_i6];\n        }\n      }\n\n      throw new Error(\"Couldn't find a genome\");\n    }\n  }, {\n    key: \"evaluateGenome\",\n    value: function evaluateGenome(genome) {\n      throw new Error(\"Method evaluateGenome() must be implemented\");\n    }\n  }]);\n\n  return Evaluator;\n}();\n\nexports.default = Evaluator;\n;"},"sourceMaps":null,"error":null,"hash":"146eb5ac871781df63623382d4c4ddda","cacheData":{"env":{}}}