{"id":"genome.js","dependencies":[{"name":"/home/vedhant/ml/neat/package.json","includedInParent":true,"mtime":1571574106382},{"name":"./connection_gene","loc":{"line":1,"column":27},"parent":"/home/vedhant/ml/neat/src/genome.js","resolved":"/home/vedhant/ml/neat/src/connection_gene.js"},{"name":"./helpers","loc":{"line":2,"column":44},"parent":"/home/vedhant/ml/neat/src/genome.js","resolved":"/home/vedhant/ml/neat/src/helpers.js"},{"name":"./node_gene","loc":{"line":3,"column":21},"parent":"/home/vedhant/ml/neat/src/genome.js","resolved":"/home/vedhant/ml/neat/src/node_gene.js"},{"name":"./parameters","loc":{"line":4,"column":23},"parent":"/home/vedhant/ml/neat/src/genome.js","resolved":"/home/vedhant/ml/neat/src/parameters.js"},{"name":"./feed_forward_network","loc":{"line":5,"column":31},"parent":"/home/vedhant/ml/neat/src/genome.js","resolved":"/home/vedhant/ml/neat/src/feed_forward_network.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _connection_gene = _interopRequireDefault(require(\"./connection_gene\"));\n\nvar _helpers = require(\"./helpers\");\n\nvar _node_gene = _interopRequireDefault(require(\"./node_gene\"));\n\nvar _parameters = _interopRequireDefault(require(\"./parameters\"));\n\nvar _feed_forward_network = _interopRequireDefault(require(\"./feed_forward_network\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Genome =\n/*#__PURE__*/\nfunction () {\n  function Genome() {\n    _classCallCheck(this, Genome);\n\n    this.id = null;\n    this.species = null;\n    this.connections = [];\n    this.nodes = [];\n    this.fitness = 0;\n  }\n\n  _createClass(Genome, [{\n    key: \"getInitialTopology\",\n    value: function getInitialTopology(inputs, outputs, connectionInnovation, nodeInnovation) {\n      var n = [];\n\n      for (var i = 0; i < inputs + outputs; ++i) {\n        n.push(nodeInnovation.getInnovation());\n      }\n\n      for (var _i = 0; _i < inputs; ++_i) {\n        this.addNode(new _node_gene.default(_node_gene.default.TYPE.INPUT, n[_i]));\n      }\n\n      for (var _i2 = 0; _i2 < outputs; ++_i2) {\n        this.addNode(new _node_gene.default(_node_gene.default.TYPE.OUTPUT, n[_i2 + inputs]));\n      }\n\n      for (var _i3 = 0; _i3 < inputs; ++_i3) {\n        for (var j = 0; j < outputs; ++j) {\n          genome.addConnection(new _connection_gene.default(n[_i3], n[inputs + j], 0.5, true, connectionInnovation.getInnovation()));\n        }\n      }\n    } // TODO: add tries\n\n  }, {\n    key: \"addConnectionMutation\",\n    value: function addConnectionMutation(connectionCounter) {\n      var node1 = this.nodes[(0, _helpers.randInt)(0, this.nodes.length - 1)];\n      var node2 = this.nodes[(0, _helpers.randInt)(0, this.nodes.length - 1)];\n      var weight = (0, _helpers.rand)(-_parameters.default.RandomWeightRange / 2, _parameters.default.RandomWeightRange / 2);\n      var reversed = false;\n      if (node1.type === _node_gene.default.TYPE.HIDDEN && node2.type === _node_gene.default.TYPE.INPUT) reversed = true;else if (node1.type === _node_gene.default.TYPE.OUTPUT && node2.type === _node_gene.default.TYPE.HIDDEN) reversed = true;else if (node1.type === _node_gene.default.TYPE.OUTPUT && node2.type === _node_gene.default.TYPE.INPUT) reversed = true;\n      var connectionImpossible = false;\n      if (node1.type === _node_gene.default.TYPE.INPUT && node2.type === _node_gene.default.TYPE.INPUT) connectionImpossible = true;else if (node1.type === _node_gene.default.TYPE.OUTPUT && node2.type === _node_gene.default.TYPE.OUTPUT) connectionImpossible = true;else if (node1.id === node2.id) connectionImpossible = true;\n      var connectionExists = false;\n\n      for (var i = 0; i < this.connections.length; ++i) {\n        if (this.connections[i].inNode === node1.id && this.connections[i].outNode === node2.id) {\n          connectionExists = true;\n          break;\n        }\n\n        if (this.connections[i].inNode === node2.id && this.connections[i].outNode === node1.id) {\n          connectionExists = true;\n          break;\n        }\n      }\n\n      if (connectionExists || connectionImpossible) return;\n      var newConnection = new _connection_gene.default(reversed ? node2.id : node1.id, reversed ? node1.id : node2.id, weight, true, connectionCounter.getInnovation());\n      this.addConnection(newConnection);\n    }\n  }, {\n    key: \"addNodeMutation\",\n    value: function addNodeMutation(nodeCounter, connectionCounter) {\n      var connection = this.connections[(0, _helpers.randInt)(0, this.connections.length - 1)];\n      var inNode = this.getNodeById(connection.inNode);\n      var outNode = this.getNodeById(connection.outNode);\n      connection.enabled = false;\n      var newNode = new _node_gene.default(_node_gene.default.TYPE.HIDDEN, nodeCounter.getInnovation());\n      var inToNew = new _connection_gene.default(inNode.id, newNode.id, 1, true, connectionCounter.getInnovation());\n      var newToOut = new _connection_gene.default(newNode.id, outNode.id, connection.weight, true, connectionCounter.getInnovation());\n      this.addNode(newNode);\n      this.addConnection(inToNew);\n      this.addConnection(newToOut);\n    }\n  }, {\n    key: \"mutateConnectionWeights\",\n    value: function mutateConnectionWeights() {\n      for (var i = 0; i < this.connections.length; ++i) {\n        if ((0, _helpers.rand)(0, 1) < _parameters.default.probEachWeightUniformPerturb) {\n          this.connections[i].weight += (0, _helpers.randGaussian)();\n        } else {\n          this.connections[i].weight = (0, _helpers.rand)(-_parameters.default.RandomWeightRange / 2, _parameters.default.RandomWeightRange / 2);\n        }\n      }\n    }\n  }, {\n    key: \"getNodeById\",\n    value: function getNodeById(id) {\n      var node = this.nodes.find(function (node) {\n        return node.id === id;\n      });\n      if (node === undefined) return null;\n      return node;\n    }\n  }, {\n    key: \"getConnection\",\n    value: function getConnection(innovation) {\n      var connection = this.connections.find(function (connection) {\n        return connection.innovation === innovation;\n      });\n      if (connection === undefined) return null;\n      return connection;\n    } // TODO: use GenesisGenome\n\n  }, {\n    key: \"randomizeAllWeights\",\n    value: function randomizeAllWeights() {\n      for (var i = 0; i < this.connections.length; ++i) {\n        this.connections[i].weight = (0, _helpers.rand)(-_parameters.default.RandomWeightRange / 2, _parameters.default.RandomWeightRange / 2);\n      }\n    }\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      var newConnections = [];\n      var newNodes = [];\n\n      for (var i = 0; i < this.connections.length; ++i) {\n        newConnections.push(this.connections[i].copy());\n      }\n\n      for (var _i4 = 0; _i4 < this.nodes.length; ++_i4) {\n        newNodes.push(this.nodes[_i4].copy());\n      }\n\n      var newGenome = new Genome();\n      newGenome.connections = newConnections;\n      newGenome.nodes = newNodes;\n      newGenome.fitness = this.fitness;\n      return newGenome;\n    }\n  }, {\n    key: \"addNode\",\n    value: function addNode(node) {\n      this.nodes.push(node);\n    }\n  }, {\n    key: \"addConnection\",\n    value: function addConnection(connection) {\n      this.connections.push(connection);\n      var net = new _feed_forward_network.default(this);\n\n      if (!net.checkCycles()) {\n        return true;\n      } else {\n        this.connections.pop();\n        return false;\n      }\n    }\n  }]);\n\n  return Genome;\n}();\n\nexports.default = Genome;\n; // parent1 should be fitter than parent2\n\nGenome.crossover = function (parent1, parent2) {\n  var child = new Genome();\n\n  for (var i = 0; i < parent1.nodes.length; ++i) {\n    var matchingNode = parent2.getNodeById(parent1.nodes[i].id);\n\n    if (matchingNode !== null) {\n      var childNodeGene = Math.random() >= 0.5 ? parent1.nodes[i].copy() : matchingNode.copy();\n      child.addNode(childNodeGene);\n    } else {\n      var _childNodeGene = parent1.nodes[i].copy();\n\n      child.addNode(_childNodeGene);\n    }\n  }\n\n  for (var _i5 = 0; _i5 < parent1.connections.length; ++_i5) {\n    var matchingConnection = parent2.getConnection(parent1.connections[_i5].innovation);\n    var childConnectionGene = void 0;\n\n    if (matchingConnection !== null) {\n      childConnectionGene = Math.random() >= 0.5 ? parent1.connections[_i5].copy() : matchingConnection.copy();\n      var disabled = !parent1.connections[_i5].enabled || !matchingConnection.enabled;\n      if (disabled && Math.random() < _parameters.default.disableGeneInheritingChance) childConnectionGene.enabled = false;\n      child.addConnection(childConnectionGene);\n    } else {\n      childConnectionGene = parent1.connections[_i5].copy();\n      child.addConnection(childConnectionGene);\n    }\n  }\n\n  return child;\n};\n\nGenome.compatibilityDistance = function (genome1, genome2) {\n  var N = Math.max(genome1.nodes.length + genome1.connections.length, genome2.nodes.length + genome2.connections.length);\n  var compatibilities = Genome.getGenesCompatibility(genome1, genome2); // TODO: check value of N\n  // N = 1;\n\n  return _parameters.default.c1 * compatibilities.excess / N + _parameters.default.c2 * compatibilities.disjoint / N + _parameters.default.c3 * compatibilities.avgWeightDiff;\n};\n\nGenome.getGenesCompatibility = function (genome1, genome2) {\n  var nodesMatching = 0,\n      connectionMatching = 0,\n      disjoint = 0,\n      excess = 0; // count matching node genes\n\n  var nodegenes1 = genome1.nodes.map(function (node) {\n    return node.id;\n  }).sort(function (id1, id2) {\n    return id1 < id2 ? -1 : 1;\n  });\n  var nodegenes2 = genome2.nodes.map(function (node) {\n    return node.id;\n  }).sort(function (id1, id2) {\n    return id1 < id2 ? -1 : 1;\n  });\n  var i = nodegenes1.length - 1;\n  var j = nodegenes2.length - 1;\n\n  while (i >= 0 && j >= 0) {\n    if (nodegenes1[i] === nodegenes2[j]) {\n      ++nodesMatching;\n      --i;\n      --j;\n    } else {\n      if (nodegenes1[i] < nodegenes2[j]) {\n        if (nodegenes2[j] > nodegenes1[nodegenes1.length - 1]) ++excess;else ++disjoint;\n        --j;\n      } else {\n        if (nodegenes1[i] > nodegenes2[nodegenes2.length - 1]) ++excess;else ++disjoint;\n        --i;\n      }\n    }\n  } // count matching connection genes\n\n\n  var weightDiff = 0;\n  var connectiongenes1 = genome1.connections.map(function (connection) {\n    return {\n      innovation: connection.innovation,\n      weight: connection.weight\n    };\n  }).sort(function (conn1, conn2) {\n    return conn1.innovation < conn2.innovation ? -1 : 1;\n  });\n  var connectiongenes2 = genome2.connections.map(function (connection) {\n    return {\n      innovation: connection.innovation,\n      weight: connection.weight\n    };\n  }).sort(function (conn1, conn2) {\n    return conn1.innovation < conn2.innovation ? -1 : 1;\n  });\n  i = connectiongenes1.length - 1;\n  j = connectiongenes2.length - 1;\n\n  while (i >= 0 && j >= 0) {\n    if (connectiongenes1[i].innovation === connectiongenes2[j].innovation) {\n      ++connectionMatching;\n      weightDiff += Math.abs(connectiongenes1[i].weight - connectiongenes2[j].weight);\n      --i;\n      --j;\n    } else {\n      if (connectiongenes1[i].innovation < connectiongenes2[j].innovation) {\n        if (connectiongenes2[j].innovation > connectiongenes1[connectiongenes1.length - 1].innovation) ++excess;else ++disjoint;\n        --j;\n      } else {\n        if (connectiongenes1[i].innovation > connectiongenes2[connectiongenes2.length - 1].innovation) ++excess;else ++disjoint;\n        --i;\n      }\n    }\n  }\n\n  var avgWeightDiff = connectionMatching > 0 ? weightDiff / connectionMatching : 0;\n  return {\n    matching: nodesMatching + connectionMatching,\n    disjoint: disjoint,\n    excess: excess,\n    avgWeightDiff: avgWeightDiff\n  };\n};"},"sourceMaps":null,"error":null,"hash":"bf7e819814e3d7f1f0e31e8a8b95e3fa","cacheData":{"env":{}}}