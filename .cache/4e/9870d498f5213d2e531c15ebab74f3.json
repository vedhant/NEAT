{"id":"feed_forward_network.js","dependencies":[{"name":"/home/vedhant/ml/neat/package.json","includedInParent":true,"mtime":1571574106382},{"name":"./node_gene","loc":{"line":1,"column":21},"parent":"/home/vedhant/ml/neat/src/feed_forward_network.js","resolved":"/home/vedhant/ml/neat/src/node_gene.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _node_gene = _interopRequireDefault(require(\"./node_gene\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// TODO: implement RNN too!\nvar FeedForwardNetwork =\n/*#__PURE__*/\nfunction () {\n  function FeedForwardNetwork(genome) {\n    _classCallCheck(this, FeedForwardNetwork);\n\n    this.network = [];\n\n    for (var i = 0; i < genome.nodes.length; ++i) {\n      this.network.push({\n        neuron: new Neuron(genome.nodes[i].id, genome.nodes[i].type),\n        incoming: [],\n        weights: []\n      });\n    }\n\n    this.network.sort(function (n1, n2) {\n      return n1.neuron.id < n2.neuron.id ? -1 : 1;\n    });\n\n    for (var _i = 0; _i < genome.connections.length; ++_i) {\n      if (genome.connections[_i].enabled) {\n        var inId = genome.connections[_i].inNode;\n        var outId = genome.connections[_i].outNode;\n        this.network[this.getNeuronIndex(outId)].incoming.push(inId);\n        this.network[this.getNeuronIndex(outId)].weights.push(genome.connections[_i].weight);\n      }\n    }\n  } // search neuron index in network using binary search\n\n\n  _createClass(FeedForwardNetwork, [{\n    key: \"getNeuronIndex\",\n    value: function getNeuronIndex(id) {\n      var l = 0,\n          r = this.network.length - 1;\n\n      while (l <= r) {\n        var m = Math.floor((l + r) / 2);\n\n        if (this.network[m].neuron.id === id) {\n          return m;\n        } else if (this.network[m].neuron.id < id) {\n          l = m + 1;\n        } else {\n          r = m - 1;\n        }\n      }\n    }\n  }, {\n    key: \"calculateNeuronOutput\",\n    value: function calculateNeuronOutput(id) {\n      var idx = this.getNeuronIndex(id);\n\n      if (this.network[idx].neuron.activated) {\n        return;\n      }\n\n      for (var i = 0; i < this.network[idx].incoming.length; ++i) {\n        this.calculateNeuronOutput(this.network[idx].incoming[i]);\n        var inNeuron = this.network[this.getNeuronIndex(this.network[idx].incoming[i])].neuron;\n        this.network[idx].neuron.value += inNeuron.value * this.network[idx].weights[i];\n      }\n\n      this.network[idx].neuron.activateSigmoid();\n    }\n  }, {\n    key: \"feed\",\n    value: function feed(inputs) {\n      var j = 0;\n\n      for (var i = 0; i < this.network.length; ++i) {\n        if (this.network[i].neuron.type === _node_gene.default.TYPE.INPUT) {\n          this.network[i].neuron.value = inputs[j];\n          this.network[i].neuron.activated = true;\n          ++j;\n        }\n\n        if (j === inputs.length) break;\n      }\n\n      var outputs = [];\n\n      for (var _i2 = 0; _i2 < this.network.length; ++_i2) {\n        if (this.network[_i2].neuron.type === _node_gene.default.TYPE.OUTPUT) {\n          this.calculateNeuronOutput(this.network[_i2].neuron.id);\n          outputs.push(this.network[_i2].neuron.value);\n        }\n      }\n\n      this.resetValues();\n      return outputs;\n    }\n  }, {\n    key: \"dfs\",\n    value: function dfs(u) {\n      var idx = this.getNeuronIndex(u);\n\n      if (!this.visited[idx]) {\n        this.visited[idx] = true;\n        this.inStack[idx] = true;\n\n        for (var i = 0; i < this.network[idx].incoming.length; ++i) {\n          var v = this.network[idx].incoming[i];\n          if (!this.visited[this.getNeuronIndex(v)] && this.dfs(v)) return true;else if (this.inStack[this.getNeuronIndex(v)]) return true;\n        }\n      }\n\n      this.inStack[idx] = false;\n      return false;\n    }\n  }, {\n    key: \"checkCycles\",\n    value: function checkCycles() {\n      this.visited = new Array(this.network.length);\n      this.visited.fill(false);\n      this.inStack = new Array(this.network.length);\n      this.inStack.fill(false);\n\n      for (var i = 0; i < this.network.length; ++i) {\n        if (this.dfs(this.network[i].neuron.id)) return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"resetValues\",\n    value: function resetValues() {\n      for (var i = 0; i < this.network.length; ++i) {\n        this.network[i].neuron.value = 0;\n        this.network[i].neuron.activated = false;\n      }\n    }\n  }]);\n\n  return FeedForwardNetwork;\n}();\n\nexports.default = FeedForwardNetwork;\n;\n\nvar Neuron =\n/*#__PURE__*/\nfunction () {\n  function Neuron(id, type) {\n    _classCallCheck(this, Neuron);\n\n    this.id = id;\n    this.type = type;\n    this.activated = false;\n    this.value = 0;\n  }\n\n  _createClass(Neuron, [{\n    key: \"activateSigmoid\",\n    value: function activateSigmoid() {\n      this.value = 1 / (1 + Math.exp(-this.value));\n      this.activated = true;\n    }\n  }, {\n    key: \"activateRelu\",\n    value: function activateRelu() {\n      this.value = Math.max(this.value, 0);\n      this.activated = true;\n    }\n  }]);\n\n  return Neuron;\n}();\n\n;"},"sourceMaps":null,"error":null,"hash":"349aaff01e09df130414baf0af7b785e","cacheData":{"env":{}}}